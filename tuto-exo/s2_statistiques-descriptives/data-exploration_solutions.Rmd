---
title: "Tuto-TP – Apprivoiser ses données – statistiques descriptives et exploratoires"
author: "Jacques van Helden"
date: '`r Sys.Date()`'
output:
  html_document:
    self_contained: TRUE
    fig_caption: yes
    highlight: zenburn
    theme: cerulean
    toc: yes
    toc_depth: 3
    toc_float: yes
    code_folding: "hide"
  ioslides_presentation:
    slide_level: 2
    self_contained: TRUE
    colortheme: dolphin
    fig_caption: yes
    fig_height: 5
    fig_width: 7
    fonttheme: structurebold
    highlight: tango
    smaller: yes
    toc: yes
    widescreen: yes
  pdf_document:
    fig_caption: yes
    highlight: zenburn
    toc: yes
    toc_depth: 3
  beamer_presentation:
    colortheme: dolphin
    fig_caption: yes
    fig_height: 5
    fig_width: 7
    fonttheme: structurebold
    highlight: tango
    incremental: no
    keep_tex: no
    slide_level: 2
    theme: Montpellier
    toc: yes
  revealjs::revealjs_presentation:
    theme: night
    transition: none
    self_contained: true
    css: ../slides.css
  slidy_presentation:
    smart: no
    slide_level: 2
    self_contained: yes
    fig_caption: yes
    fig_height: 5
    fig_width: 7
    highlight: tango
    incremental: no
    keep_md: yes
    smaller: yes
    theme: cerulean
    toc: yes
    widescreen: yes
  powerpoint_presentation:
    slide_level: 2
    fig_caption: yes
    fig_height: 5
    fig_width: 7
    toc: yes
font-import: http://fonts.googleapis.com/css?family=Risque
subtitle: Proba/stat pour la biologie (SBGAU14L)
font-family: Garamond
transition: linear
editor_options: 
  chunk_output_type: console
---


```{r settings, include=FALSE, echo=FALSE, eval=TRUE}

options(width = 300)
# options(encoding = 'UTF-8')
knitr::opts_chunk$set(
  fig.width = 7, fig.height = 5, 
  fig.path = 'figures/canale23_',
  fig.align = "center", 
  size = "tiny", 
  echo = TRUE, 
  eval = TRUE, 
  warning = FALSE, 
  message = FALSE, 
  results = TRUE, 
  comment = "")

options(scipen = 12) ## Max number of digits for non-scientific notation
# knitr::asis_output("\\footnotesize")

```


## Abbreviations

| Abbreviation | Meaning |
|--------------|----------------------------------------|
| LFQ | Label-Free Quantification |
| log2 | base-2 logarithm |
| IQR | inter-quartile range |
| Q1 | First quartile |
| Q2 | Second quartile = median |
| Q3 | Third quartile |

## Study case

Canale (2023) ... (summary TO BE WRITTEN)

## Downloading and loading a data file

In this section, we will 

- create a working directory for this tutorial
- download the data file from the web in this directory
- load it in R
- check the content of this file

### Creating your working directory

On your computer, create a folder for this practical. For this tutorial, we will assume that this folder is named `canale23_analysis`  and is located at the root of your home directory. 

The code hereafter will create this directory for you. 

```{r workdir}
#### Working directory ####

# Define the path of the working directory
wd = "~/proba_stat_bio_TP/canale_2023"

# Create the working directory
dir.create(wd, showWarnings = FALSE, recursive = TRUE)

setwd(wd)
list.files()

```

### Downloading datasets from the server



```{r data_download}

## This  chunk of code below automatically performs the following operations
## 1. Define the working directory, check if it exists and if not create it
## 2. Define the data directory, check if it exists and if not create it
## 3. Download the proteomics data (quantification table) 
##    and metadata (protein names, sample groups) in the data directory. 
##    If the files are already present, the download is skipped. 

## Working dir 
working_dir <- "~/proba_stat_bio_TP/canale_2023"
dir.create(working_dir, recursive = TRUE, showWarnings = FALSE)
setwd(working_dir)
message("Working directory: ", working_dir)

#### Check data dieectory and create it if necessary ####
data_dir <- file.path(working_dir, "data")
dir.create(data_dir, recursive = TRUE, showWarnings = FALSE)
message("Data directory: ", data_dir)


## Define file names
files <- c("canale_2023_protein_log2-LFQ.tsv", 
           "canale_2023_protein-names.tsv", 
           "sample_groups.tsv")

## Download the data from github to the local data dir
repo_base <- "https://raw.githubusercontent.com/jvanheld/proba-stat-bio_SBGAU14L/refs/heads/main/data/canale_2023/"


for (f in files) {
  ## Define the destination path (data dir + file name)
  dest_file <- file.path(data_dir, f)
  
  ## Check if the file is already there, and if so skip, else download it
  if (file.exists(dest_file)) {
    message("File ", f, " already here, skipping the download")
  } else {
    source_url <- file.path(repo_base, f)
    message("Downloading file ", f, " from github")
    download.file(source_url, dest_file, quiet = FALSE)
  }
}

```

| | |
|-----------------------|----------------------------------------------------|
| Working directory: | `r working_dir` |
| Data directory: | `r data_dir` |
| Files present in the data directory | `r list.files(data_dir)` |

### Data loading


We will load 3 data files, that will be used at different stages of our analysis. 
These files are provided as text files, with columns separated by tabulations (the so-called "tab-separated values" format, with extension `.tsv`).

| File | Content |
|------------------------------|-------------------------------------------|
| `canale_2023_protein_log2-LFQ.tsv` | The proteomics quantification table, with one row per protein, and one column per sample. Note that the first column provides protein IDs, and the first row sample IDs |
| `canale_2023_protein-names.tsv` | One row per protein, and columns with the protein IDs, protein names and gene names. Note that a protein can have one or more IDs (allocated by different databases), and zero, one or more protein or gene names (some proteins/genes of unknown function have no name, ans some proteins/genes can have several synonyms). |
| `sample_groups.tsv` | A 3-columns tab-separated files containing one row per sample ID (first column, used as row names), and its decomposition in two fields indicating the group to which each sample belongs, and the patient ID (number). In this study case, there are only two groups : **HCC** for Human cancer cells, and **Liver** for liver cells.

```{r data_loading}
message("Loading the datasets")

#### Load the data file ####
log2_LFQ = read.delim(
  file = file.path(data_dir, "canale_2023_protein_log2-LFQ.tsv"), 
  sep="\t", 
  header=TRUE, 
  row.names=1)

## Load a separate table indicating which sample belongs to which group (cancer or liver cells)
sample_groups = read.delim(
  file.path(data_dir, "sample_groups.tsv"), 
  sep="\t", 
  header=TRUE, 
  row.names=1)

## Load the protein names from a separate table
protein_names = read.delim(file = file.path(data_dir, "canale_2023_protein-names.tsv"), sep = "\t")
```

The data and metadata files have been loaded in the following R variables. 

| Variable | Rows | Columns | Content | 
|-------------|-----|------|------------------------------------|
| `log2_LFQ` | `r nrow(log2_LFQ)` | `r ncol(log2_LFQ)` | Protein quantification table, in log2(LFQ), where LFQ stands for label-free quantification. One row per protein, one column per sample |
| `protein_names` | `r nrow(protein_names)` | `r ncol(protein_names)` | Protein identifiers, protein names and gene names. One row per protein |
| `sample_groups` | `r nrow(sample_groups)` | `r ncol(sample_groups)` | One row per sample, two columns inidicating its group and its patient identifier (number) |




## Distribution of the data values

### Histogram

***Exercice :** lisez la documentation de la fonction `hist()`, et améliorez l'histogramme ci-dessous en modifiant le titre, les étiquettes des axes, et les autres paramètres qui vous sembleront pertinents. *

```{r hist_log2_LFQ_altogether, fig.cap="Histogram of log2(LFQ) values from Canale's whole proteomics dataset. "}
#### Generate a histogram with the log2(LFQ) values of all the samples together ####

hist(unlist(log2_LFQ))

```

***Votre interprétation : ** ajoutez ici vos commentaires concernant la forme générale de cet histogramme. *


### Box plot

***Exercice : ** utilisez la fonction  R `boxplot()` pour visualiser ces données sous forme de boîtes à moustaches. Utilisez différentes options pour rendre cette figure aussi claire que possible. *

**Astuces :**
- il existe une option permettant d'afficher les boîtes à moustaches horizontalement, ce qui facilite la lecture des étiquettes associées à chaque échantillon
- l'option `las=1` permet d'afficher horizontalement les étiquettes des deux axes, ce qui facilite leur lecture

```{r box_plot, fig.width=8, fig.height=12, out.width="100%", fig.cap="Boxplot of Canale's data. "}

# boxplot(log2_LFQ)

## Define colors per sample according to the sample group
#ifelse(test = sample_groups$group == "HCC", "violet", "yellow")
group_colors <- c("HCC"="violet", Liver="yellow")
sample_groups$color <- group_colors[sample_groups$group]

boxplot(log2_LFQ, 
        horizontal = TRUE, 
        las=1, 
        cex.axis=0.7, 
        col=sample_groups$color, 
        main="Box plot of proteomics data", 
        xlab="log2(LFQ)")
legend("bottomright", legend = names(group_colors), fill = group_colors, cex = 0.9)

```
**Votre interprétation : ** observez la médiane et l'espace inter-quartile des échantillons. Identifiez les échantillons qui auraient une distribution différente des autres. 

### Violin plot

Installez la librairie `vioplot` et chargez-la dans R. 

```{r violin_plot, fig.width=8, fig.height=12, out.width="100%", fig.cap="Violin plot of Canale's data. "}
#### Draw a violin plot ####

## Install vioplot library if required, and load it
if (!require(vioplot)) {
  install.packages("vioplot")
}
library(vioplot)

## Install vioplot library if required, and load it
vioplot(log2_LFQ,
        horizontal = TRUE,
        names = rep("", ncol(log2_LFQ)),  # supprime labels auto
        las = 1,
        cex.axis = 0.7,
        col = sample_groups$color,
        main = "Violin plot of proteomics data",
        xlab = "log2(LFQ)")

# Ajout manuel des labels sur l'axe Y
axis(2, at = 1:ncol(log2_LFQ), labels = colnames(log2_LFQ), las = 2, cex.axis = 0.7)
legend("bottomright", legend = names(group_colors), fill = group_colors, cex = 0.9)

```


### Heat map

## Protein filtering

The histogram below indicates the number of NA values per protein. 


```{r na_per_protein, fig.width=8, fig.height=5, out.width="90%", fig.cap="Number of NA values per protein. The color scale highlighhts the caution to be taken for proteins with high number of NA values. "}
#### Treat the number  of NA values per sample ####

## Count the number of NA values per protein (row)
na_per_protein <- apply(is.na(log2_LFQ), 1, sum)

## Generate a color palette from pink to green
col_fun <- colorRampPalette(c("lightgreen", "red"))
n_breaks <- ncol(log2_LFQ) + 1  # nb d’intervalles = nb breaks + 1

## Draw a histogram with the number of NA values per sample
hist(na_per_protein - 0.5, 
     breaks = -1:ncol(log2_LFQ),
     las = 1,
     main = "Number of NA values per protein",
     xlab = "Number of NA values",
     ylab = "Number of proteins",
     col = col_fun(n_breaks),
     border = "grey")

```

**Observations: **

- The histogram spreads over all values from `r min(na_per_protein)` to `r max(na_per_protein)` NA values per protein.
- `r na_per_protein[ncol(log2_LFQ)]` proteins have NA values in all the samples (columns)
- The number of proteins with measurements in all the colums is a minority : only `r na_per_protein[0]` proteins have not a single NA value


We suppress the rows (proteins) containing too many NA values. 


```{r protein_filtering}
#### 
## Create a clean data.frame by suppressing the lines (proteins) containing only NA values
min_values_per_prot <- 5
log2_LFQ_clean <- log2_LFQ[na_per_protein >= min_values_per_prot, ]
nrow(log2_LFQ_clean)

```

For this, we arbitrarily set a threshold with the minimal number of values per protein: we suppress all the proteins (rows) having less than  `r min_values_per_prot` NA values. Among the `r nrow(log2_LFQ)` proteins of the initial table, the filtered keeps  `r nrow(log2_LFQ_clean)`. 



### Principal components

```{r eval=FALSE}

if (!requireNamespace("BiocManager", quietly = TRUE)) {
  install.packages("BiocManager") 
}
BiocManager::install("pcaMethods")

library(pcaMethods)



## Compute principal components from samples (columns by transposing the data table)
pca_samples <- pca(t(log2_LFQ_clean), method = "nipals", nPcs = 5, scale = "uv")

## Compute PC scores for each protein
scores <- scores(res_pca)
dim(scores)
plot(scores[,1], scores[,2],
     xlab = "PC1", ylab = "PC2",
     main = "ACP avec NIPALS (valeurs manquantes gérées)",
     pch = 19)


## Compute principal components from proteins (rows)
res_pca <- pca(log2_LFQ_clean, method = "nipals", nPcs = 5, scale = "uv")

## Compute PC scores for each protein
scores <- scores(res_pca)
dim(scores)
plot(scores[,1], scores[,2],
     xlab = "PC1", ylab = "PC2",
     main = "ACP avec NIPALS (valeurs manquantes gérées)",
     pch = 19)
```



## Descriptive statistics


## Standardizing the data table


## Descriptive statistics

```{r}
summary(log2_LFQ)

```

## Handling NA values

```{r na_handling}
## Count NA values per row
## dim(na.omit(log2_LFQ))
## table(apply(is.na(log2_LFQ), 1, sum) == 0)
na_per_row = apply(is.na(log2_LFQ), 1, sum)
hist(na_per_row, 
     col="#FFBBBB",
     breaks=(0:70)-0.5,
     main = "Missing values per protein", 
     xlab = " Number of NA values", 
     ylab = "Number of proteins")
```

## Standardization

### Heat map of the log2(LFQ)

```{r heatmap_log2LFQ, fig.width=12, fig.height=12, out.width="100%", fig.cap="**Heatmap of the proteome abundance.**  Rows: proteins;  Columns: samples. The color scale is proportional to  log2(LFQ) values. Note that the data table contains 8192 proteins, whereas the figure is 2304w2304 pixels. Rows of the heatmap thus represent a subset of the proteins. "}
heatmap(as.matrix(log2_LFQ), Rowv = NA, Colv=NA, 
        scale="none", labRow=NA,
#        main="Canale (2023), log2(LFQ)",
        cexCol = 0.7, 
#        xlab = "samples", 
        ylab = "Proteins log2(LFQ)")
```

### Dataset-wise standardization

```{r standardisation}

```


### Protein-wise standardization

```{r protein_standardization}
#### Protein-wise standardization ####

## Protein means
mean_per_protein = apply(log2_LFQ, 1, mean, na.rm=TRUE)

## Protein means
sd_per_protein = apply(log2_LFQ, 1, sd, na.rm=TRUE)

## Center proteins
protein_centred = sweep(log2_LFQ, MARGIN = 1, STATS = mean_per_protein, FUN = "-", check.margin = TRUE)


## Compute protein-wise standrardized abundances (centred and scaled)
protein_stand = sweep(protein_centred, MARGIN = 1, STATS = sd_per_protein, FUN = "/", check.margin  = TRUE)

## Check the ranges before and after centering and standardization
range(log2_LFQ, na.rm = TRUE) # Range of all abundances before standardization
range(protein_centred, na.rm = TRUE) # Range of all abundances after centering
range(apply(protein_centred, 1, mean, na.rm = TRUE), na.rm=TRUE) # Range of the means per protein after centering
range(protein_stand, na.rm = TRUE) # Range of all abundances after standardization
range(apply(protein_stand, 1, mean, na.rm = TRUE), na.rm=TRUE) # Range of the means per protein after centering
range(apply(protein_stand, 1, sd, na.rm = TRUE), na.rm=TRUE) # Range of the standard deviation per protein after centering
```

```{r hist_parameters_per_protein, fig.width=14, fig.height=4, out.width="100%", fig.cap="**Protein-wise parameters. **"}

par(mfrow=c(1,2))
hist(mean_per_protein, main="Means per protein", breaks=100, xlab= "mean(log2(LFQ))", ylab="Number of proteins", col="#66FFFF")
hist(sd_per_protein, main="Standard deviations per protein", breaks=100, xlab= "sd(log2(LFQ))", ylab="Number of proteins", col="#FFDDBB")

par(mfrow=c(1,1))

```

```{r hist_standardized_abundances, fig.width=7, fig.height=10, out.width="70%", fig.cap="**Protein abundance values before and after protein-wise standardization**"}

par(mfrow=c(3,1))

hist(unlist(log2_LFQ), breaks=100, main="Before protein-wise standardization", 
     col = "#FFFFBB",
     xlab="log2(LFQ)", ylab = "Number of proteins")
abline(v=mean(unlist(log2_LFQ), na.rm=TRUE), lwd=2, col="#0000FF")

hist(unlist(protein_centred), breaks=100, main="After protein-wise centering",
     col = "#BBDDFF",
     xlab="log2(LFQ) - protein-wise mean(log2(LFQ)", ylab = "Number of proteins")
abline(v=0, lwd=2, col="#0000FF")

hist(unlist(protein_stand), breaks=100, main="After protein-wise standardization",
     col = "#BBFFDD",
     xlab="z-score of log2(LFQ)", ylab = "Number of proteins")
abline(v=0, lwd=2, col="#0000FF")

par(mfrow=c(1,1))

```


```{r heatmap_log2LFQ_std, fig.width=12, fig.height=12, out.width="100%", fig.cap="**Heatmap of the  protein-wise standardized abundances**  Rows: proteins;  Columns: samples. The color scale reflects the protein-wise standardized  log2(LFQ) values (z-scores, i.e. centred to 0 and scaled to 1). Note that the data table contains 8192 proteins, whereas the figure is 2304w2304 pixels. Rows of the heatmap thus represent a subset of the proteins. "}

## Choose a palette to distinguish negative from positive values
my_colors <- colorRampPalette(c("green", "white", "red"))(100)
zlim <- quantile(abs(protein_stand), na.rm = TRUE, probs = 0.95)
breaks <- seq(-zlim, zlim, length.out = 101)

heatmap(as.matrix(protein_stand), Rowv = NA, Colv=NA, 
        scale="none", 
        col = my_colors,
        breaks = breaks,
        labRow=NA,
        main="Protein-wise standardized log2(LFQ)",
        cexCol = 0.7, 
        xlab = NA, 
        ylab = "Protein-wise z-scores of log2(LFQ)")


```
