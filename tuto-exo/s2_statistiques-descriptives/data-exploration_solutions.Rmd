---
title: "Tuto-TP – Apprivoiser ses données – statistiques descriptives et exploratoires"
author: "Jacques van Helden (ORCID [0000-0002-8799-8584](https://orcid.org/0000-0002-8799-8584))"
date: '`r Sys.Date()`'
subtitle: Proba/stat pour la biologie (SBGAU14L)
output:
  html_document:
    self_contained: yes
    fig_caption: yes
    highlight: zenburn
    theme: cerulean
    toc: yes
    toc_depth: 3
    toc_float: yes
    code_folding: "hide"
  ioslides_presentation:
    slide_level: 2
    self_contained: TRUE
    colortheme: dolphin
    fig_caption: yes
    fig_height: 5
    fig_width: 7
    fonttheme: structurebold
    highlight: tango
    smaller: yes
    toc: yes
    widescreen: yes
  pdf_document:
    fig_caption: yes
    highlight: zenburn
    toc: yes
    toc_depth: 3
  beamer_presentation:
    colortheme: dolphin
    fig_caption: yes
    fig_height: 5
    fig_width: 7
    fonttheme: structurebold
    highlight: tango
    incremental: no
    keep_tex: no
    slide_level: 2
    theme: Montpellier
    toc: yes
  revealjs::revealjs_presentation:
    theme: night
    transition: none
    self_contained: true
    css: ../slides.css
  slidy_presentation:
    smart: no
    slide_level: 2
    self_contained: yes
    fig_caption: yes
    fig_height: 5
    fig_width: 7
    highlight: tango
    incremental: no
    keep_md: yes
    smaller: yes
    theme: cerulean
    toc: yes
    widescreen: yes
  powerpoint_presentation:
    slide_level: 2
    fig_caption: yes
    fig_height: 5
    fig_width: 7
    toc: yes
---


```{r settings, include=FALSE, echo=FALSE, eval=TRUE}
library(knitr)

options(width = 300)
# options(encoding = 'UTF-8')
knitr::opts_chunk$set(
  fig.width = 7, fig.height = 5, 
  fig.path = 'figures/canale23_',
  fig.align = "center", 
  size = "tiny", 
  echo = TRUE, 
  eval = TRUE, 
  warning = FALSE, 
  message = FALSE, 
  results = TRUE, 
  comment = "")

options(scipen = 12) ## Max number of digits for non-scientific notation
# knitr::asis_output("\\footnotesize")

```


## Abbreviations

| Abbreviation | Meaning |
|--------------|----------------------------------------|
| LFQ | Label-Free Quantification |
| log2 | base-2 logarithm |
| IQR | inter-quartile range |
| Q1 | First quartile |
| Q2 | Second quartile = median |
| Q3 | Third quartile |

## Study case

Canale (2023) ... (summary TO BE WRITTEN)

## Downloading and loading a data file

In this section, we will 

- create a working directory for this tutorial
- download a data file and 2 metadata files from the web
- load these three files in R, in `data.frame` structures
- check the content of these data frames


### Downloading datasets from the github repository


```{r data_download}

## This  chunk of code below automatically performs the following operations
## 1. Define the working directory, check if it exists and if not create it
## 2. Define the data directory, check if it exists and if not create it
## 3. Download the proteomics data (quantification table) 
##    and metadata (protein names, sample groups) in the data directory. 
##    If the files are already present, the download is skipped. 

## Working dir 
working_dir <- "~/proba_stat_bio_TP/canale_2023"
dir.create(working_dir, recursive = TRUE, showWarnings = FALSE)
setwd(working_dir)
message("Working directory: ", working_dir)

#### Check data directory and create it if necessary ####
data_dir <- file.path(working_dir, "data")
dir.create(data_dir, recursive = TRUE, showWarnings = FALSE)
message("Data directory: ", data_dir)


## Define file names
files <- c("canale_2023_protein_log2-LFQ.tsv", 
           "canale_2023_protein-names.tsv", 
           "sample_groups.tsv")

## Download the data from github to the local data dir
repo_base <- "https://raw.githubusercontent.com/jvanheld/proba-stat-bio_SBGAU14L/refs/heads/main/data/canale_2023/"


for (f in files) {
  ## Define the destination path (data dir + file name)
  dest_file <- file.path(data_dir, f)
  
  ## Check if the file is already there, and if so skip, else download it
  if (file.exists(dest_file)) {
    message("File ", f, " already here, skipping the download")
  } else {
    source_url <- file.path(repo_base, f)
    message("Downloading file ", f, " from github")
    download.file(source_url, dest_file, quiet = FALSE)
  }
}

```


| | |
|-----------------------|----------------------------------------------------|
| Working directory: | `r working_dir` |
| Data directory: | `r data_dir` |
| Files present in the data directory | `r list.files(data_dir)` |

### Data loading


We will load 3 data files, that will be used at different stages of our analysis. 
These files are provided as text files, with columns separated by tabulations (the so-called "tab-separated values" format, with extension `.tsv`).

| File | Content |
|------------------------------|-------------------------------------------|
| `canale_2023_protein_log2-LFQ.tsv` | The proteomics quantification table, with one row per protein, and one column per sample. Note that the first column provides protein IDs, and the first row sample IDs |
| `canale_2023_protein-names.tsv` | One row per protein, and columns with the protein IDs, protein names and gene names. Note that a protein can have one or more IDs (allocated by different databases), and zero, one or more protein or gene names (some proteins/genes of unknown function have no name, ans some proteins/genes can have several synonyms). |
| `sample_groups.tsv` | A 3-columns tab-separated files containing one row per sample ID (first column, used as row names), and its decomposition in two fields indicating the group to which each sample belongs, and the patient ID (number). In this study case, there are only two groups : **HCC** for Human cancer cells, and **Liver** for liver cells.

```{r data_loading}
message("Loading the datasets")

#### Load the data file ####
log2_LFQ = read.delim(
  file = file.path(data_dir, "canale_2023_protein_log2-LFQ.tsv"), 
  sep="\t", 
  header=TRUE, 
  row.names=1)

## Load a separate table indicating which sample belongs to which group (cancer or liver cells)
sample_groups = read.delim(
  file.path(data_dir, "sample_groups.tsv"), 
  sep="\t", 
  header=TRUE, 
  row.names=1)

## Load the protein names from a separate table
protein_names = read.delim(file = file.path(data_dir, "canale_2023_protein-names.tsv"), sep = "\t")
```

The data and metadata files have been loaded in the following R variables. 

| Variable | Rows | Columns | Content | 
|-------------|-----|------|------------------------------------|
| `log2_LFQ` | `r nrow(log2_LFQ)` | `r ncol(log2_LFQ)` | Protein quantification table, in log2(LFQ), where LFQ stands for label-free quantification. One row per protein, one column per sample |
| `protein_names` | `r nrow(protein_names)` | `r ncol(protein_names)` | Protein identifiers, protein names and gene names. One row per protein |
| `sample_groups` | `r nrow(sample_groups)` | `r ncol(sample_groups)` | One row per sample, two columns inidicating its group and its patient identifier (number) |

In the table above, check carefully the consistency between the dimensions of the 3 tables : 

- `protein_names` should have the same number of rows as `log2_LFQ` (one row per protein)
- the number of rows of `sample_groups` (one row per sample) should equal the number of columns of `log2_LFQ` (one column per sample)



## Exploration of the data values

### Histogram

#### Exercice 1

Nous avons généré ci-dessous un histogramme de base pour représener la distribution de toutes les valeurs quantitatives du protéome, après avoir écarté les valeurs manquantes (*NA*). 

- Lisez la documentation de la fonction `hist()`, en prêtant une attention particulière aux options suivantes: `main`, `xlab`, `ylab`, `col`, `border`, `las`.
- Améliorez l'histogramme en modifiant le titre, les étiquettes des axes, la couleur, et les autres paramètres qui vous sembleront pertinents. 


```{r hist_log2_LFQ_altogether, fig.width=7, fig.height=4.5, out.width="100%", fig.cap="Histogram of log2(LFQ) values from Canale's whole proteomics dataset. "}
## Create a vector with all the numeric values of the proteome quantification
x <- na.omit(unlist(log2_LFQ))

#### Generate a histogram with the log2(LFQ) values of all the samples together ####
hist(x)

```


```{r hist_log2_LFQ_altogether_pretty, fig.width=8, fig.height=5, out.width="100%", fig.cap="Histogram of log2(LFQ) values from Canale's whole proteomics dataset. "}
## Create a vector with all the numeric values of the proteome quantification
x <- na.omit(unlist(log2_LFQ))

#### Generate a histogram with the log2(LFQ) values of all the samples together ####
hist(x, 
     main = "Distribution of proteome quantification values", ## Title of the figure
     xlab = "log2(LFQ)", ## Label on the X axis
     ylab = "Occurrences", ## Label on the Y axis
     breaks=100, ## Increase the number of breaks to better evaluate the shape of the distribution
     las = 1,   ## Display axis labels horizontally
     col = "lightblue")
grid() ## Add a discrete grid to mark the X and Y levels

```

***Votre interprétation : ** ajoutez ici vos commentaires concernant la forme générale de cet histogramme. *

**Observations: **

- The distribution is asymmetric, with a right-side skew (longer tail on the right than on the left)
- The distribution is roughly unimodal (a single peak), but we see a "shoulder" between X values 27 and 30
- Globally, the shape of the distribution does not look to follow a norma distribution or any other specific theoretical distribution, but this is not surprising. Actually,  we don't expect *a priori* that this curve would follow a normal distribution, or any particular distribution, because it represents values for >8000 proteins, each of which is expected to have a specific level (concentration) related to transcriptional and post-transcriptional regulation



### Réduction des données

Le tableau en annexe 1 récapitule les principales statistiques utilisées pour caractériser les propriétés d'un jeu de données quantitatives. 

#### Exercice 2

Calculez les paramètres suivants sur l'ensemble des données du tableau de quantification du protéome. Stockez les paramètres dans une liste nommée `proteome_parameters`, en associant les étiquettes suivantes aux paramètres. 

- `mean`: moyenne
- `var` :variance
- `sd`: écart-type (standard deviation)
- `Q1`: premier quartile
- `min` : minimum
- `median` : médiane
- `Q3` : troisième quartile
- `max` : maximum
- `IQR`: Ecart interquartile

**Astuces :**

- pour vous faciliter la tâche, nous avons initié la liste de paramètres avec les 3 premières statistiques, à vous de la compléter
- il n'existe pas de fonction R qui calcule directement les quartile ou les percentiles, mais la fonction `quantiles()` vous permet de les calculer facilement. 
- la fonction `quantiles()` retourne une valeur avec une "étiquette" indiquant le paramètre de probabilité que vous avez fourni. Ce paramètre peut être utile dans certains cas, mais dans la structure de liste ci-dessous il est perturbant car il s'ajoute automatiquement au nom de l'élément de la liste. Pour obtenir un résultat propre, combinez les fonctions `quantile(à`et `unname()`de la façon suivante:  `unname(quantile(prob = ...))`. 

Note: dans cette solution, nous avons calculé pour vous les paramètres de dyssimétrie ($g_1$) et d'aplatissement ($g_2$), qui ne faisaient pas partie de l'énoncé.

```{r proteome_parameters}
## Compute a vector with the non-NA values of the proteome quantification
x <- na.omit(unlist(log2_LFQ))

## Compute descriptive statistics with the all the numeric values of the proteome
proteome_parameters <- list()

proteome_parameters$mean <- mean(x)
proteome_parameters$var <- var(x)
proteome_parameters$sd <- sd(x)
proteome_parameters$min <- min(x)
proteome_parameters$P05 <- unname(quantile(x, 0.05)) ## Percentile 05. I add unname() to avoid automatic inclusion of the percents in the variable name
proteome_parameters$Q1 <- unname(quantile(x, 0.25))
proteome_parameters$median <- median(x)
proteome_parameters$Q3 <- unname(quantile(x, 0.75))
proteome_parameters$P95 <- unname(quantile(x, 0.95)) ## Percentile 95
proteome_parameters$max <- max(x, 0.75)
proteome_parameters$IQR <- IQR(x, 0.75)


## Skewness : Fisher's g1 parameter
proteome_parameters$g1 <- mean((x - proteome_parameters$mean)^3) / proteome_parameters$sd^3

## Kurtosis : Fisher's g2 parameter
## Note: the Normal distribution is characterized by g2=0
proteome_parameters$g2 <- (mean((x - proteome_parameters$mean)^4) / proteome_parameters$sd^4) - 3

## Print a nicely formatted table in the report generated by knit. 
## For this we use the function kable() from the knit package
kable(unlist(proteome_parameters), col.names = "values", caption = "Descriptive statistics computed on all the non-NA proteome values")

```


#### Exercice 3

Nous avons retracé l'histogramme des valeurs de quantification, en utilisant les fonctions `ablines()` pour marquer la moyenne, et `arrows()` pour dessiner un intervalle couvrant 1 écart-type de chaque côté de la moyenne. Lisez l'aide des fonctions `abline` et `arrows` en faisant le lien entre les arguments utilisés et le résultat graphique. Ajouter ensuite les instructions pour dessiner également : 

- une barre verticale marquant la médiane
- deux barres verticales marquant le premier et le troisième quartile
- une flèche marquant l'espace interquartile*

```{r hist_with_parameters, fig.width=8, fig.height=5, out.width="80%", fig.cap="Histogramme des valeurs de protéome avec les paramètres de tendance centrale et de dispersion"}
x <- na.omit(unlist(log2_LFQ))

### Draw a histogram ###
hist(x, breaks = 100, 
     main = "Distribution of proteome quantification values", 
     xlab="log2_LFQ", 
     ylab="Frequency", 
     col="lightblue",
     border = "white",
     las=1)

## Mark the mean
abline(v = proteome_parameters$mean, col = "blue", lwd = 3)

## Mark a range extending over 1 standard deviation on each side of the mean
arrows(x0 = proteome_parameters$mean - proteome_parameters$sd, ## Left limit of the arrow
       x1 = proteome_parameters$mean + proteome_parameters$sd, ## Right limit of the arrow
       y0 = 4000, ## Height of the arrow
       y1 = 4000, ## Height of the arrow
       lwd=3, ## Line width
       code = 3,  ## Draw arrowheads on both sides of the arrow
       length=0.1, ## Length of the arrowheads relative to the arrow
       angle=30,   ## Angle of the arrowheads
       col = "darkviolet"
       )

## Mark the median
abline(v = proteome_parameters$median, 
       col = "darkgreen", 
       lwd = 5)

## Mark the quartiles
abline(v = proteome_parameters$Q1, col = "brown", lwd = 2)
abline(v = proteome_parameters$Q3, col = "brown", lwd = 2)


## Mark the interquartile range
arrows(x0 = proteome_parameters$Q1, ## First quartile
       x1 = proteome_parameters$Q3, ## Third quartile
       y0 = 4500, ## Height of the arrow
       y1 = 4500, ## Height of the arrow
       lwd = 5, ## Line width
       code = 3,  ## Draw arrowheads on both sides of the arrow
       length = 0.1, ## Length of the arrowheads relative to the arrow
       angle=30,   ## Angle of the arrowheads
       col = "brown")

## Add a legend on the graph
legend("topright",  ## Position of the legend
       legend = c("mean", 
                  "mean ± sd",
                  "IQR",
                  "Q1",
                  "median",
                  "Q3"),  ## text of the legend
       col = c("blue", 
               "darkviolet",
               "darkgreen",
               "brown",
               "brown",
               "brown"
               ), ## Colors of the legend elements
       lwd=c(3, 3, 5, 2, 5, 2), 
       bty="n") ## no border around the legend


## Add a legent with the numeric values
legend("topleft",
       legend = c(
         paste0("mean=", round(proteome_parameters$mean, 2)),
         paste0("Q1=", round(proteome_parameters$Q1, 2)),
         paste0("median=", round(proteome_parameters$median, 2)),
         paste0("Q3=", round(proteome_parameters$Q3, 2)),
         paste0("sd=", round(proteome_parameters$sd, 2)),
         paste0("IQR=", round(proteome_parameters$IQR, 2)),
         paste0("g1=", round(proteome_parameters$g1, 2)),
         paste0("g2=", round(proteome_parameters$g2, 2))
         ),
       bty="n")

```


### Statistiques marginales : statistiques par ligne (protéine)

#### Exercice 4

Dans le bloc de code ci-dessous, nous avons utilisé la fonction `apply()` pour  calculer la moyenne de chaque protéine, et nous avons stocké le résultat dans un vecteur nommé `mean_per_protein`. Notez que nous avons ajouté l'option `na.rm = TRUE`, que la fonction `apply()` transmet à la fonction `mean()`. 

- Dessinez un histogramme avec la distribution des moyennes par protéines


```{r hist_mean_per_protein, fig.width=8, fig.height=5, out.width="80%", fig.cap="Distribution of the mean per protein. "}
#### Compute marginal statistics per line (protein) ####

## Mean per protein
mean_per_protein <- apply(log2_LFQ, 1, mean, na.rm = TRUE)


## Histogram of the means per protein

hist(mean_per_protein, breaks=100, col="lightgreen", border="white",
     main="Mean per protein",
     xlab="mean(log2(LFQ))",
     ylab="Number of proteins",
     las=1)
grid()

```


Dans le bloc de code ci-dessous, 

- Calculez l'écart-type de chaque protéine et stockez le résultat dans un vecteur nommé `sd_per_protein` 
- Dessinez un histogramme avec la distribution des écarts-types par protéines
- Au moyen de la fonction R `plot()`, dessinez un nuage de points (scatter plot) avec en abcsisse la moyenne par protéine et en ordonnée l'écart-type par protéine


```{r hist_sd_per_protein}
## Standard deviation per protein
sd_per_protein <- apply(log2_LFQ, 1, sd, na.rm = TRUE)

## Histogram of the sd per protein
hist(sd_per_protein, breaks=100, col="orange", border="white",
     main="Standard deviation per protein",
     xlab="sd(log2(LFQ))",
     ylab="Number of proteins",
     las=1)
grid()


```

```{r hist_protein_mean_vs_sd, fig.width=7, fig.height=7, out.width="100%", fig.cap="Mean versus standard deviation per protein. "}


## Compute density colors to highlight regions with many overlapping dots
cols <- densCols(mean_per_protein, sd_per_protein)

## Dot plot with the standard deviation as a function of the mean per protein
plot(mean_per_protein, sd_per_protein,
     main = "Mean vs SD per protein",
     xlab="Mean log2(LFQ) per protein",
     ylab="Standard deviation of  log2(LFQ) per protein",
     col = cols, pch = 16, cex = 0.6,
     panel.first=grid(lty="solid", col="grey"),
     las = 1)

```


### Statistiques marginales : statistiques par colonne (échantillon)

#### Exercice 5

- utilisez la fonction `apply()` pour calculer la moyenne par colonne (échantillon), et stockez le résultat dans un vecteur nommé `mean_per_sample`
- utilisez la fonction `barplot()` pour visualiser les moyennes

```{r barplot_mean_per_sample, fig.height=4, fig.width=12, out.width="100%", fig.cap="Barplot of the mean per sample"}
### Draw a barplot with the mean per sample (column) of the proteome table

mean_per_sample <- apply(log2_LFQ, 2, mean, na.rm=TRUE)
# barplot(mean_per_sample,
#         main = "Mean per sample",
#         cex.names = 0.5,
#         horiz=TRUE,
#         las = 1)
barplot(mean_per_sample,
        main = "Mean per sample",
        cex.names = 0.5,
        col = sample_groups$color,
        horiz = FALSE,
        las = 2)


```

### Box plot

#### Exercice 6

utilisez la fonction  R `boxplot()` pour visualiser ces données sous forme de boîtes à moustaches. Utilisez différentes options pour rendre cette figure aussi claire que possible. *

**Astuces :**
- il existe une option permettant d'afficher les boîtes à moustaches horizontalement, ce qui facilite la lecture des étiquettes associées à chaque échantillon
- l'option `las=1` permet d'afficher horizontalement les étiquettes des deux axes, ce qui facilite leur lecture

```{r box_plot, fig.width=8, fig.height=12, out.width="100%", fig.cap="Boxplot of Canale's data. "}

# boxplot(log2_LFQ)

## Define colors per sample according to the sample group
#ifelse(test = sample_groups$group == "HCC", "violet", "yellow")
group_colors <- c("HCC"="violet", Liver="yellow")
sample_groups$color <- group_colors[sample_groups$group]

boxplot(log2_LFQ, 
        horizontal = TRUE, 
        las=1, 
        cex.axis=0.7, 
        col=sample_groups$color, 
        main="Box plot of proteomics data", 
        xlab="log2(LFQ)")
legend("bottomright", legend = names(group_colors), fill = group_colors, cex = 0.9)

```
**Votre interprétation : ** observez la médiane et l'espace inter-quartile des échantillons. Identifiez les échantillons qui auraient une distribution différente des autres. 

### Violin plot

Installez la librairie `vioplot` et chargez-la dans R. 

```{r violin_plot, fig.width=8, fig.height=12, out.width="100%", fig.cap="Violin plot of Canale's data. "}
#### Draw a violin plot ####

## Install vioplot library if required, and load it
if (!require(vioplot)) {
  install.packages("vioplot")
}
library(vioplot)

## Install vioplot library if required, and load it
vioplot(log2_LFQ,
        horizontal = TRUE,
        names = rep("", ncol(log2_LFQ)),  # supprime labels auto
        las = 1,
        cex.axis = 0.7,
        col = sample_groups$color,
        main = "Violin plot of proteomics data",
        xlab = "log2(LFQ)")

# Ajout manuel des labels sur l'axe Y
axis(2, at = 1:ncol(log2_LFQ), labels = colnames(log2_LFQ), las = 2, cex.axis = 0.7)
legend("bottomright", legend = names(group_colors), fill = group_colors, cex = 0.9)

```


### Heat map of the log2(LFQ)

Ci-dessous, nous avons utilisé la fonction `heatmap()` pour dessiner une carte de couleur du tableau `log2_LFQ`. 

- Veillez à désactiver le clustering des lignes et des colonnes (options `Rowv`et `Colv)
- désactivez également la standardization (option `scale`)


```{r heatmap_log2LFQ, fig.width=12, fig.height=12, out.width="100%", fig.cap="**Heatmap of the proteome abundance.**  Rows: proteins;  Columns: samples. The color scale is proportional to  log2(LFQ) values. Note that the data table contains 8192 proteins, whereas the figure is 2304w2304 pixels. Rows of the heatmap thus represent a subset of the proteins. "}
heatmap(as.matrix(log2_LFQ), 
        main="Canale (2023), log2(LFQ)",
        Rowv = NA, 
        Colv=NA, 
        scale="none", 
        labRow=NA,
        cexCol = 0.7, 
        xlab = "samples", 
        ylab = "Proteins log2(LFQ)")
```


## Protein filtering

The histogram below indicates the number of NA values per protein. 


```{r na_per_protein, fig.width=8, fig.height=5, out.width="90%", fig.cap="Number of NA values per protein. The color scale highlighhts the caution to be taken for proteins with high number of NA values. "}
#### Treat the number  of NA values per sample ####

## Count the number of NA values per protein (row)
na_per_protein <- apply(is.na(log2_LFQ), 1, sum)
# range(na_per_protein)

## Generate a color palette from pink to green
col_fun <- colorRampPalette(c("lightgreen", "red"))
n_breaks <- ncol(log2_LFQ) + 1  # nb d’intervalles = nb breaks + 1

## Draw a histogram with the number of NA values per sample
hist(na_per_protein, 
     breaks = -0.5:(ncol(log2_LFQ)+0.5),
     las = 1,
     main = "Number of NA values per protein",
     xlab = "Number of NA values",
     ylab = "Number of proteins",
     col = col_fun(n_breaks),
     border = "white")

```

**Observations: **

- The histogram spreads over all values from `r min(na_per_protein)` to `r max(na_per_protein)` NA values per protein.
- `r na_per_protein[ncol(log2_LFQ)]` proteins have NA values in all the samples (columns)
- The number of proteins with measurements in all the colums is a minority : only `r na_per_protein[0]` proteins have not a single NA value


We suppress the rows (proteins) containing too many NA values. 


```{r protein_filtering}
#### 
## Create a clean data.frame by suppressing the lines (proteins) containing only NA values
min_values_per_prot <- 5
log2_LFQ_clean <- log2_LFQ[na_per_protein >= min_values_per_prot, ]
#nrow(log2_LFQ_clean)

```

For this, we arbitrarily set a threshold with the minimal number of values per protein: we suppress all the proteins (rows) having less than  `r min_values_per_prot` NA values. Among the `r nrow(log2_LFQ)` proteins of the initial table, the filtered keeps  `r nrow(log2_LFQ_clean)`. 



### Principal components

```{r eval=FALSE}

if (!requireNamespace("BiocManager", quietly = TRUE)) {
  install.packages("BiocManager") 
}
BiocManager::install("pcaMethods")

library(pcaMethods)



## Compute principal components from samples (columns by transposing the data table)
pca_samples <- pca(t(log2_LFQ_clean), method = "nipals", nPcs = 5, scale = "uv")

## Compute PC scores for each protein
scores <- scores(res_pca)
dim(scores)
plot(scores[,1], scores[,2],
     xlab = "PC1", ylab = "PC2",
     main = "ACP avec NIPALS (valeurs manquantes gérées)",
     pch = 19)


## Compute principal components from proteins (rows)
res_pca <- pca(log2_LFQ_clean, method = "nipals", nPcs = 5, scale = "uv")

## Compute PC scores for each protein
scores <- scores(res_pca)
dim(scores)
plot(scores[,1], scores[,2],
     xlab = "PC1", ylab = "PC2",
     main = "ACP avec NIPALS (valeurs manquantes gérées)",
     pch = 19)
```



## Standardizing the data table


## Standardization

### Dataset-wise standardization

```{r standardisation}

```


### Protein-wise standardization

```{r protein_standardization}
#### Protein-wise standardization ####

## Protein means
mean_per_protein = apply(log2_LFQ, 1, mean, na.rm=TRUE)

## Protein means
sd_per_protein = apply(log2_LFQ, 1, sd, na.rm=TRUE)

## Center proteins
protein_centred = sweep(log2_LFQ, MARGIN = 1, STATS = mean_per_protein, FUN = "-", check.margin = TRUE)


## Compute protein-wise standrardized abundances (centred and scaled)
protein_stand = sweep(protein_centred, MARGIN = 1, STATS = sd_per_protein, FUN = "/", check.margin  = TRUE)

## Check the ranges before and after centering and standardization
range(log2_LFQ, na.rm = TRUE) # Range of all abundances before standardization
range(protein_centred, na.rm = TRUE) # Range of all abundances after centering
range(apply(protein_centred, 1, mean, na.rm = TRUE), na.rm=TRUE) # Range of the means per protein after centering
range(protein_stand, na.rm = TRUE) # Range of all abundances after standardization
range(apply(protein_stand, 1, mean, na.rm = TRUE), na.rm=TRUE) # Range of the means per protein after centering
range(apply(protein_stand, 1, sd, na.rm = TRUE), na.rm=TRUE) # Range of the standard deviation per protein after centering
```



```{r hist_standardized_abundances, fig.width=7, fig.height=10, out.width="70%", fig.cap="**Protein abundance values before and after protein-wise standardization**"}

par(mfrow=c(3,1))

hist(unlist(log2_LFQ), breaks=100, main="Before protein-wise standardization", 
     col = "#FFFFBB",
     xlab="log2(LFQ)", ylab = "Number of proteins")
abline(v=mean(unlist(log2_LFQ), na.rm=TRUE), lwd=2, col="#0000FF")

hist(unlist(protein_centred), breaks=100, main="After protein-wise centering",
     col = "#BBDDFF",
     xlab="log2(LFQ) - protein-wise mean(log2(LFQ)", ylab = "Number of proteins")
abline(v=0, lwd=2, col="#0000FF")

hist(unlist(protein_stand), breaks=100, main="After protein-wise standardization",
     col = "#BBFFDD",
     xlab="z-score of log2(LFQ)", ylab = "Number of proteins")
abline(v=0, lwd=2, col="#0000FF")

par(mfrow=c(1,1))

```


```{r heatmap_log2LFQ_std, fig.width=12, fig.height=12, out.width="100%", fig.cap="**Heatmap of the  protein-wise standardized abundances**  Rows: proteins;  Columns: samples. The color scale reflects the protein-wise standardized  log2(LFQ) values (z-scores, i.e. centred to 0 and scaled to 1). Note that the data table contains 8192 proteins, whereas the figure is 2304w2304 pixels. Rows of the heatmap thus represent a subset of the proteins. "}

## Choose a palette to distinguish negative from positive values
my_colors <- colorRampPalette(c("green", "white", "red"))(100)
zlim <- quantile(abs(protein_stand), na.rm = TRUE, probs = 0.95)
breaks <- seq(-zlim, zlim, length.out = 101)

heatmap(as.matrix(protein_stand), Rowv = NA, Colv=NA, 
        scale="none", 
        col = my_colors,
        breaks = breaks,
        labRow=NA,
        main="Protein-wise standardized log2(LFQ)",
        cexCol = 0.7, 
        xlab = NA, 
        ylab = "Protein-wise z-scores of log2(LFQ)")


```

## Appendices

### Appendix 1: descriptive statistics : sample parameters

**Note :** les formules ci-dessous sont celles définies pour calculer des paramètres d'échantillons. Ces paramètres visent uniquement à décrire les données disponible.  

Des formules légèrement différentes sont utilisées pour estimer les paramètres d'une population à partir d'un échantillon, comme nous le verrons dans le chapitre **"Echantillonnage et estimation"**. 

| Statistique |  Description | Formule |
|-----------------------|---------------------------|------------------------------------|
| Moment  | Moment d'ordre $k$ par rapport à une constante $c$  | $\frac{1}{n} \sum_{i=1}^{n} (x_i - c)^k$ |
| Moment  | Moment d'ordre $k$ par rapport à l'origine  | $a_k = \frac{1}{n} \sum_{i=1}^{n} x_i^k$ |
| Moyenne d'échantillon (sample mean) | Tendance centrale | $\bar{x} = a_1 = \frac{1}{n} \sum_{i=1}^{n} x_i$ |
| Moment centré | Moment d'ordre $k$ par rapport à la moyenne  | $m_k = \frac{1}{n} \sum_{i=1}^{n} (x_i - \bar{x})^k$ |
| Variance d'échantillon (sample variance) | Dispersion | $s^2 = m_2 = \frac{1}{n} \sum_{i=1}^{n} (x_i - \bar{x})^2$ |
| Ecart-type d'échantillon (sample standard deviation) | Dispersion | $s = \sqrt{s^2} = \sqrt{ \frac{1}{n} \sum_{i=1}^{n} (x_i - \bar{x})^2 }$ |
| Skewness | Dissymétrie | $g_1 = m_3 / s^3 = \frac{ \frac{1}{n} \sum_{i=1}^{n} (x_i - \bar{x})^3 }{ \left( \sqrt{ \frac{1}{n} \sum_{i=1}^{n} (x_i - \bar{x})^2 } \right)^3 }$ |
| Kurtosis = peakedness | Coefficient d'acuité (d'aplatissement, de voussure) | $g_2 = m_4 / s^4 - 3 = \frac{ \frac{1}{n} \sum_{i=1}^{n} (x_i - \bar{x})^4 }{ \left( \frac{1}{n} \sum_{i=1}^{n} (x_i - \bar{x})^2 \right)^2 }$ |
| Quantile | Valeur minimale qui "plafonne" (supérieure ou égale à) une certaine proportion $p$ des $n$ observations | $Q(p) = x_{(\lceil n p \rceil)}, p \in [0,1]$ |
| Premier quartile |   | $Q_1 = Q(0.25)$ |
| Médiane (médiane) | Tendance centrale (robuste aux valeurs aberrantes) | $\tilde{x} = Q_2 = Q(0.5)$ |
| Troisième quartile |   | $Q_3 = Q(0.75)$ |
| Ecart interquartile | Dispersion (robuste aux valeurs aberrantes) | $\text{IQR} = Q_3 - Q_1$ |
