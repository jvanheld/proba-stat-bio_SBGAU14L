---
title: "Tuto-TP – Apprivoiser ses données"
author: "Votre Nom"
date: "`r Sys.Date()`"
output:
  html_document:
    self_contained: true
    fig_caption: true
    highlight: zenburn
    theme: cerulean
    toc: true
    toc_depth: 3
    toc_float: true
    code_folding: hide
  pdf_document:
    toc: true
    toc_depth: '3'
  word_document:
    toc: true
    toc_depth: '3'
editor_options: 
  chunk_output_type: console
---

```{r settings, include=FALSE, echo=FALSE, eval=TRUE}
#### Parameters for compiling the report with knitr ####
## This section can be considered as a black box
library(knitr)

options(width = 300)
options(encoding = 'UTF-8')
knitr::opts_chunk$set(
  fig.width = 7,                  # default width for the figures generated in R chunks
  fig.height = 5,                 # default height for the figures generated in R chunks
  fig.path = 'figures/canale23_', # folder and prefix for the figures generated in R chunks
  fig.align = "center",           # default alignment for the figures generated in R chunks
  size = "tiny",
  echo = TRUE,                    # echo the messages during the knit compilaiton
  eval = TRUE,                    # by default, evalute (=run) the code in all chunks, unless otherwise speficied
  warning = FALSE,                # include R warnings in the knit document
  message = FALSE,                # include messages in the knit document
  results = TRUE,                 # include the results (e.f. of print() calls) in the knit document 
  comment = "")

options(scipen = 12) ## Max number of digits for non-scientific notation
# knitr::asis_output("\\footnotesize")

```



## Downloading datasets from the server



```{r data_download}

## This  chunk of code below automatically performs the following operations
## 1. Define the working directory, check if it exists and if not create it
## 2. Define the data directory, check if it exists and if not create it
## 3. Download the proteomics data (quantification table) 
##    and metadata (protein names, sample groups) in the data directory. 
##    If the files are already present, the download is skipped. 

## Working dir 
working_dir <- "~/proba_stat_bio_TP/canale_2023"
dir.create(working_dir, recursive = TRUE, showWarnings = FALSE)
setwd(working_dir)
message("Working directory: ", working_dir)

#### Check data dieectory and create it if necessary ####
data_dir <- file.path(working_dir, "data")
dir.create(data_dir, recursive = TRUE, showWarnings = FALSE)
message("Data directory: ", data_dir)


## Define file names
files <- c("canale_2023_protein_log2-LFQ.tsv", 
           "canale_2023_protein-names.tsv", 
           "sample_groups.tsv")

## Download the data from github to the local data dir
repo_base <- "https://raw.githubusercontent.com/jvanheld/proba-stat-bio_SBGAU14L/refs/heads/main/data/canale_2023/"


for (f in files) {
  ## Define the destination path (data dir + file name)
  dest_file <- file.path(data_dir, f)
  
  ## Check if the file is already there, and if so skip, else download it
  if (file.exists(dest_file)) {
    message("File ", f, " already here, skipping the download")
  } else {
    source_url <- file.path(repo_base, f)
    message("Downloading file ", f, " from github")
    download.file(source_url, dest_file, quiet = FALSE)
  }
}

```

| | |
|-----------------------|----------------------------------------------------|
| Working directory: | `r working_dir` |
| Data directory: | `r data_dir` |
| Files present in the data directory | `r list.files(data_dir)` |

## Data loading


```{r data_loading}
message("Loading the datasets")

#### Load the data file ####
log2_LFQ = read.delim(
  file = file.path(data_dir, "canale_2023_protein_log2-LFQ.tsv"), 
  sep="\t", 
  header=TRUE, 
  row.names=1)

## Load a separate table indicating which sample belongs to which group (cancer or liver cells)
sample_groups = read.delim(
  file.path(data_dir, "sample_groups.tsv"), 
  sep="\t", 
  header=TRUE, 
  row.names=1)

## Load the protein names from a separate table
protein_names = read.delim(file = file.path(data_dir, "canale_2023_protein-names.tsv"), sep = "\t")
```

We loaded the data and metadata files in the following variables. 

| Variable | Rows | Columns | Content | 
|-------------|-----|------|------------------------------------|
| `log2_LFQ` | `r nrow(log2_LFQ)` | `r ncol(log2_LFQ)` | Protein quantification table, in log2(LFQ), where LFQ stands for label-free quantification. One row per protein, one column per sample |
| `protein_names` | `r nrow(protein_names)` | `r ncol(protein_names)` | Protein identifiers, protein names and gene names. One row per protein |
| `sample_groups` | `r nrow(sample_groups)` | `r ncol(sample_groups)` | One row per sample, two columns inidicating its group and its patient identifier (number) |

In the table above, check carefully the consistency between the dimensions of the 3 tables : 

- `protein_names` should have the same number of rows as `log2_LFQ` (one row per protein)
- the number of rows of `sample_groups` (one row per sample) should equal the number of columns of `log2_LFQ` (one column per sample)

## Exploration of the data values

### Histogram

**Exercice :** Nous avons généré ci-dessous un histogramme de base pour représener la distribution de toutes les valeurs quantitatives du protéome, après avoir écarté les valeurs manquantes (*NA*). 

- Lisez la documentation de la fonction `hist()`, en prêtant une attention particulière aux options suivantes: `main`, `xlab`, `ylab`, `col`, `border`, `las`.
- Améliorez l'histogramme en modifiant le titre, les étiquettes des axes, la couleur, et les autres paramètres qui vous sembleront pertinents. 

```{r hist_log2_LFQ_altogether, fig.height=4.5, fig.width=7, out.width="50%",  fig.cap="Histogram of log2(LFQ) values from Canale's whole proteomics dataset. "}
## Create a vector with all the numeric values of the proteome quantification
x <- na.omit(unlist(log2_LFQ))

#### Generate a histogram with the log2(LFQ) values of all the samples together ####
hist(x)

```



***Votre interprétation : ** ajoutez ici vos commentaires concernant la forme générale de cet histogramme. *



### Réduction des données

Le tableau en annexe 1 récapitule les principales statistiques utilisées pour caractériser les propriétés d'un jeu de données qsuantitatives. 

**Note :** les paramètres ci-dessous portent uniquement sur les observations dont nous disposons. Des formules légèrement différentes seront utilisées dans le chapitre **"Echantillonnage et estimation"** pour estimer les paramètres d'une population à partir d'un échantillon. 


**Exercice** : Calculez les paramètres suivants sur l'ensemble des données du tableau de quantification du protéome. Stockez les paramètres dans une liste nommée `proteome_parameters`, en associant les étiquettes suivantes aux paramètres. 

- `mean`: moyenne
- `var` :variance
- `sd`: écart-type (standard deviation)
- `Q1`: premier quartile
- `min` : minimum
- `median` : médiane
- `Q3` : troisième quartile
- `max` : maximum
- `IQR`: Ecart interquartile

**Astuces :**

- pour vous faciliter la tâche, nous avons initié la liste de paramètres avec les 3 premières statistiques, à vous de la compléter
- il n'existe pas de fonction R qui calcule directement les quartile ou les percentiles, mais la fonction `quantiles()` vous permet de les calculer facilement. 
- la fonction `quantiles()` retourne une valeur avec une "étiquette" indiquant le paramètre de probabilité que vous avez fourni. Ce paramètre peut être utile dans certains cas, mais dans la structure de liste ci-dessous il est perturbant car il s'ajoute automatiquement au nom de l'élément de la liste. Pour obtenir un résultat propre, combinez les fonctions `quantile(à`et `unname()`de la façon suivante:  `unname(quantile(prob = ...))`. 


```{r proteome_parameters}
## Compute a vector with the non-NA values of the proteome quantification
x <- na.omit( ## Suppress NA values from the vectorized valors
  unlist(log2_LFQ)   ## convert the data.frame in a vector with all the values for all proteins and all samples
  )

## Compute descriptive statistics with the all the numeric values of the proteome
proteome_parameters <- list() ## Create an empty list

proteome_parameters$mean <- mean(x)  ## Add an element to the list with the mean of all the observations
proteome_parameters$var <- var(x)
proteome_parameters$sd <- sd(x)
proteome_parameters$Q1 <- unname(quantile(x, probs = 0.25))
proteome_parameters$median <- median(x)
proteome_parameters$Q3 <- unname(quantile(x, probs = 0.75))
proteome_parameters$IQR <- IQR(x)


## Print a nicely formatted table in the report generated by knit. 
## For this we use the function kable() from the knit package
kable(unlist(proteome_parameters), 
      col.names = "values", 
      caption = "Descriptive statistics computed on all the non-NA proteome values")

```


**Exercice:** Nous avons retracé l'histogramme des valeurs de quantification, en utilisant les fonctions `ablines()` pour marquer la moyenne, et `arrows()` pour dessiner un intervalle couvrant 1 écart-type de chaque côté de la moyenne. Lisez l'aide des fonctions `abline` et `arrows` en faisant le lien entre les arguments utilisés et le résultat graphique. Ajouter ensuite les instructions pour dessiner également : 

- une barre verticale marquant la médiane
- deux barres verticales marquant le premier et le troisième quartile
- une flèche marquant l'espace interquartile

```{r hist_with_parameters, fig.width=7, fig.height=4, out.width="80%", fig.cap="Histogramme des valeurs de protéome avec les paramètres de tendance centrale et de dispersion"}
### Draw a histogram ###
hist(x, breaks = 100, main = "Distribution of proteome quantification values", xlab="log2_LFQ", ylab="Frequency", col="lightblue", las=1)

## Mark the mean
abline(v = proteome_parameters$mean, col = "blue", lwd = 3)

## Mark a range extending over 1 standard deviation on each side of the mean
arrows(x0 = proteome_parameters$mean - proteome_parameters$sd, ## Left limit of the arrow
       x1 = proteome_parameters$mean + proteome_parameters$sd, ## Right limit of the arrow
       y0 = 4000, ## Height of the arrow
       y1 = 4000, ## Height of the arrow
       lwd=3, ## Line width
       code = 3,  ## Draw arrowheads on both sides of the arrow
       length=0.1, ## Length of the arrowheads relative to the arrow
       angle=30,   ## Angle of the arrowheads
       col = "darkviolet"
       )

## Mark the median
###  ADD YOUR CODE HERE ###

## Mark the first quartile
###  ADD YOUR CODE HERE ###

## Mark the third quartile
###  ADD YOUR CODE HERE ###

## Mark the interquartile range
###  ADD YOUR CODE HERE ###

## Add a legend on the graph
legend("topright",  ## Position of the legend
       legend = c("mean", "mean ± sd"),  ## text of the legend
       col = c("blue", "darkviolet"), lwd=3, ## Colors of the legent elements
       bty="n") ## no border around the legend


```


### Statistiques marginales : statistiques par ligne (protéine)

**Exercice :** Dans le bloc de code ci-dessous, nous avons utilisé la fonction `apply()` pour  calculer la moyenne de chaque protéine, et nous avons stocké le résultat dans un vecteur nommé `mean_per_protein`. Notez que nous avons ajouté l'option `na.rm = TRUE`, que la fonction `apply()` transmet à la fonction `mean()`. 

- Dessinez un histogramme avec la distribution des moyennes par protéines


```{r hist_mean_per_protein}
#### Compute marginal statistics per line (protein) ####

## Mean per protein
mean_per_protein <- apply(log2_LFQ, 1, mean, na.rm = TRUE)


## Histogram of the means per protein

### A VOUS DE JOUER ###

```

Dans le bloc de code ci-dessous, 

- Calculez l'écart-type de chaque protéine et stockez le résultat dans un vecteur nommé `sd_per_protein` 
- Dessinez un histogramme avec la distribution des écarts-types par protéines
- Au moyen de la fonction R `plot()`, dessinez un nuage de points (scatter plot) avec en abcsisse la moyenne par protéine et en ordonnée l'écart-type par protéine


```{r hist_sd_per_protein}
## Standard deviation per protein

### A VOUS DE JOUER ###



## Histogram of the sd per protein

### A VOUS DE JOUER ###



```

```{r hist_protein_mean_vs_sd, fig.width=7, fig.height=7, out.width="100%", fig.cap="Mean versus standard deviation per protein. "}

## Dot plot with the standard deviation as a function of the mean per protein

### A VOUS DE JOUER ###

```


### Statistiques marginales : statistiques par colonne (échantillon)

**Exercice :**

- utilisez la fonction `apply()` pour calculer la moyenne par colonne (échantillon), et stockez le résultat dans un vecteur nommé `mean_per_sample`
- utilisez la fonction `barplot()` pour visualiser les moyennes

```{r barplot_mean_per_sample}
### Draw a barplot with the mean per sample (column) of the proteome table


### A VOUS DE JOUER ###

```


### Box plot

***Exercice : ** utilisez la fonction  R `boxplot()` pour visualiser le tableau de données protéomiques sous forme de boîtes à moustaches. Utilisez différentes options pour rendre cette figure aussi claire que possible. *

**Astuces :**
- il existe une option permettant d'afficher les boîtes à moustaches horizontalement, ce qui facilite la lecture des étiquettes associées à chaque échantillon
- l'option `las=1` permet d'afficher horizontalement les étiquettes des deux axes, ce qui facilite leur lecture

```{r box_plot, fig.width=8, fig.height=12, out.width="100%", fig.cap="Boxplot of Canale's data. "}

### ADD YOUR CODE HERE ###

```

**Votre interprétation : ** observez la médiane et l'espace inter-quartile des échantillons. Identifiez les échantillons qui auraient une distribution différente des autres. 



## Appendices

### Appendix 1: descriptive statistics : sample parameters

| Statistique |  Description | Formule |
|-----------------------|---------------------------|------------------------------------|
| Moment  | Moment d'ordre $k$ par rapport à une constante $c$  | $\frac{1}{n} \sum_{i=1}^{n} (x_i - c)^k$ |
| Moment  | Moment d'ordre $k$ par rapport à l'origine  | $a_k = \frac{1}{n} \sum_{i=1}^{n} x_i^k$ |
| Moyenne d'échantillon (sample mean) | Tendance centrale | $\bar{x} = a_1 = \frac{1}{n} \sum_{i=1}^{n} x_i$ |
| Moment centré | Moment d'ordre $k$ par rapport à la moyenne  | $m_k = \frac{1}{n} \sum_{i=1}^{n} (x_i - \bar{x})^k$ |
| Variance d'échantillon (sample variance) | Dispersion | $s^2 = m_2 = \frac{1}{n} \sum_{i=1}^{n} (x_i - \bar{x})^2$ |
| Ecart-type d'échantillon (sample standard deviation) | Dispersion | $s = \sqrt{s^2} = \sqrt{ \frac{1}{n} \sum_{i=1}^{n} (x_i - \bar{x})^2 }$ |
| Skewness | Dissymétrie | $g_1 = m_3 / s^3 = \frac{ \frac{1}{n} \sum_{i=1}^{n} (x_i - \bar{x})^3 }{ \left( \sqrt{ \frac{1}{n} \sum_{i=1}^{n} (x_i - \bar{x})^2 } \right)^3 }$ |
| Kurtosis = peakedness | Coefficient d'acuité (d'aplatissement, de voussure) | $g_2 = m_4 / s^4 - 3 = \frac{ \frac{1}{n} \sum_{i=1}^{n} (x_i - \bar{x})^4 }{ \left( \frac{1}{n} \sum_{i=1}^{n} (x_i - \bar{x})^2 \right)^2 }$ |
| Quantile | Valeur minimale qui "plafonne" (supérieure ou égale à) une certaine proportion $p$ des $n$ observations | $Q(p) = x_{(\lceil n p \rceil)}, p \in [0,1]$ |
| Premier quartile |   | $Q_1 = Q(0.25)$ |
| Médiane (médiane) | Tendance centrale (robuste aux valeurs aberrantes) | $\tilde{x} = Q_2 = Q(0.5)$ |
| Troisième quartile |   | $Q_3 = Q(0.75)$ |
| Ecart interquartile | Dispersion (robuste aux valeurs aberrantes) | $\text{IQR} = Q_3 - Q_1$ |
