---
title: "Tuto/exo: tirage de nombres d'une distribution de probabilité"
author: "Jacques van Helden (ORCID [0000-0002-8799-8584](https://orcid.org/0000-0002-8799-8584))"
date: "`r Sys.Date()`"
output:
  html_document:
    code_folding: hide
    collapsed: yes
    fig_caption: yes
    highlight: zenburn
    theme: cerulean
    toc: yes
    toc_depth: 3
    toc_float: yes
  pdf_document:
    fig_caption: yes
    highlight: zenburn
    toc: yes
    toc_depth: 3
  html_notebook:
    code_folding: show
    collapsed: no
    fig_caption: yes
    highlight: zenburn
    theme: cerulean
    toc: yes
    toc_depth: 3
    toc_float: yes
editor_options:
  chunk_output_type: console
---

## Tutoriel

Dans ce tutoriel, nous illustrons quelques concepts de base de l'échantillonnage statistique, et proposons quelques exercices pour vous familiariser avec ces concepts, et avec les fonctions R pertinentes. 


```{r sampling_nomal_simple}
# Generate 100,000 numbers from a normal distribution with mean=0 and standard deviation=1
x <- rnorm(n = 100000, mean = 0, sd = 1)

# Plot a histogram of the generated numbers
hist(x, 
     main="Distribution of 100,000 random numbers from a normal distribution",
     xlab="Value")
```

### Séparation entre paramètres et exécution

Nous réécrivons ce script minimaliste en séparant les paramètres. Ceci

- améliore la lisibilité du code, 
- permet d'enrichir la documentation (commenter chaque paramètre)
- permet tester l'impact des paramètres sur le résultat

Nous utilisons la fonction `paste0()` pour écrire le titre du graphique en y incluant la valeur numérique de ces paramètres. 

Astuce : par défaut, R affiche les grands nombres en notation scientifique (ex `1e+5`). Pour éviter cela, ous remplaçons `n` par `format(n, scientific=FALSE)` dans la commande `paste0()`. 

Par convention, nous nommerons 

- `mu` la variable R qui désigne la moyenne de la distribution théorique (par référence au symbole grec $\mu$ conventionnellement utilisé)
- `sigma` la variable R qui désigne l'écart-type de la distribution théorique (par référence au symbole grec $\sigma$)




```{r sampling_normal_param}
# Parameters
n <- 100000 # Sample size
mu <- 50     # Mean of the normal distribution
sigma <- 5      # Standard deviation of the normal distribution

# Sample n numbers in a normal population of mean mu and standard deviation sigma
x <- rnorm(n = n, mean = mu, sd = sigma)

# Plot a histogram of the generated numbers
hist(x,
     main=paste0("Sampling from a normal distribution",
                 "\n", # newline character
                 "n=", format(n, scientific = FALSE),
                 ", m=", mu,
                 ", s=", sigma),
     xlab="Value")

```



## Exercice 1 : tirage de nombres dans une distribution aléatoire


### Distribution normale (gaussienne)

Améliorez la présentation de l'histogramme, de la façon suivante: 

- utilisez l'option `breaks` pour réduire la largeur des intervalles de classe
- choisissez une couleur qui vous plaît pour le corps et les contours de l'histogramme
- adaptez les options pour afficher horizontalement les étiquettes des axes X et Y

```{r sampling_normal}
# Parameters
n <- 100000 # Sample size
mu <- 50     # Mean of the normal distribution
sigma <- 5      # Standard deviation of the normal distribution

# Sample n numbers in a normal population of mean mu and standard deviation sigma
x <- rnorm(n = n, mean = mu, sd = sigma)

# Plot a histogram of the generated numbers
hist(x, 
     breaks = 100,
     col="skyblue",
     border = "white",
     las = 1,
     main=paste0("Sampling from a normal distribution",
                 "\n", # newline character
                 "n=", format(n, scientific = FALSE),
                 ", m=", mu,
                 ", s=", sigma))


abline(v=mu, lwd=2, col="brown") ## mark the mean
arrows(x0 = mu - sigma, x1 = mu + sigma, 
       y0 = n / 100,  y1 = n/100, 
       code = 3, length = 0.1, lwd=2, 
       col="brown") ## Mark an interval of ± 1 standard deviation around the mean
grid() ## Add a grid

```



## Exercice 2 : tirages aléatoires dans quelques distributions théoriques


Dans les sous-sections suivantes, ajoutez des blocs de code pour effectuer un tirage dans
-les distributions suivantes

- uniforme (fonction `runif()`) allant de -5 à +5
- $\chi^2$ chi carrée (`rchisq()`) avec 5 degrés de liberté
- Poisson (`rpois()`)) avec une espérance $\lambda=5$ 

Dans chaque cas, dessinez un histogramme pour représenter la distribution des valeurs obtenues, en indiquant le nom de la distribution et les paramètres dans le titre du graphique.

Jouez ensuite sur les paramètres pour évaluer leur impact sur la forme de la distribution. 

### Distribution uniforme


```{r sampling_uniform}

# Plot a histogram of the generated numbers
n <- 100000
my_min <- -5
my_max <- +5
x <- runif(n = n, min = my_min, max = my_max)
hist(x, 
     breaks = 100,
     col="skyblue",
     border = "white",
     las = 1,
     xlim=c(my_min, my_max), # define the limits of X axis to ensure consistency
     main=paste0("Sampling from a uniform distribution",
                 "\n", # newline character
                 "n=", format(n, scientific = FALSE),
                "; min=", my_min,
                "; max=", my_max))
## manually add a vertical grid 
abline(v=seq(from = my_min, 
             to = my_max, 
             length.out=11), 
       col = "darkgrey") 
abline(v=c(my_min, my_max), lwd=2, col="blue") # Mark the limits
abline(v=(my_max + my_min)/2, lwd=2, col="brown") # Mark the mean


```


### Distribution chi carrée ($\chi^2$)

```{r sampling_chi2}

# Plot a histogram of the generated numbers
n <- 100000
my_df <- 5
x <- rchisq(n = n, df = my_df)
hist(x, 
     breaks = 100,
     col="skyblue",
     border = "white",
     las = 1,
     main=paste0("Sampling from a chi-squared distribution",
                 "\n", # newline character
                 "n=", format(n, scientific = FALSE),
                ", df=", my_df))
abline(v=my_df, lwd=2, col="brown")
grid()

```

### Distribution de Poisson

**Astuces : **

- Pour la distribution Poisson, utilisez des intervalles de classe séparés par des pas de 1, allant de -0.5 jusqu'à $x_{max}+0.5$, où $x_{max}$ est le maximum des valeurs de $x$ obtenues dans votre tirage aléatoire. Pour cela, utilisez les fonctions `seq()`, `max()`. 


```{r sampling_poisson}

# Plot a histogram of the generated numbers
n <- 100000
my_lambda <- 5
x <- rpois(n = n, lambda = my_lambda)
hist(x, 
     breaks = -0.5:(max(x)+0.5),
     col="skyblue",
     border = "white",
     las = 1,
     main=paste0("Sampling from a Poisson distribution",
                 "\n", # newline character
                 "n=", format(n, scientific = FALSE),
                ", lambda=", my_lambda))
abline(v=my_lambda, lwd=2, col="brown")
grid()

```


****************************************************************

## Exercice 3 : distribution d'échantillonnage de la moyenne

Dans cet exercice, nous allons étudier la distribution d'échantillonnage de la moyenne, autrement dit la distribution des moyennes d'un grand nombre d'échantillons tirés aléatoirement dans une distribution théorique de notre choix (en commençant par la distribution uniforme). 

Pour cela, nous allons créer une matrice dont chaque ligne représente un tirage aléatoire  nombres, dont nous calculerins ensuite la moyenne. 

Par convention, nous nommerons nos variables

- `r` pour le nombre de répétitions de l'essai, correspondant au nombre de lignes de la matrice
- `n` pour la taille de l'échantillon, correspondant au nombre de colonnes de la matrice

**Exercice**

- Créez une matrice (`matrix()`) de `r=10000` lignes et `n=5` colonnes, que vous remplirez avec des nombres aléatoires tirés dans une distribution uniforme (`runif()`) entre $-5$ et $5$. 

- Calculez la moyenne marginale sur les lignes de cette matrice
- Dessinez un histogramme avec les valeurs de ces moyennes marginales
- Marquez d'une barre verticale la moyenne théorique
- Dans une autre couleur, marquez d'une barre verticale la moyenne observée pour l'ensemble de vos tirages
- Interprétez les résultats : quelle est la forme générale de la moyenne d'échantillonnage ? Ressemble-t-elle à la distribution théorique dont vous avez tiré les nombres ? Ressemble-t-elle à une autre distribution théorique que vous connaissez ?


```{r sampling_means_unif}

# Plot a histogram of the generated numbers
r <- 100000     # repetitions
n <- 5          # sample size for each repetition
my_min <- -5    # min of the uniform distribution
my_max <- +5    # max of the uniform distribution

## Draw random numbers 
x <- runif(n = n * r, min = -5, max = +5)

## Inject the numbers in a matrix with r rows and n columns
x_matrix <- matrix(data = x, nrow = r, ncol = n)

## Compute sample means
sample_means <- apply(X = x_matrix, MARGIN = 1, FUN = mean)

## Compute some statistics about the sample means
means_m <- mean(sample_means) # compute the mean of the sample means
means_s <- sd(sample_means) # compute the standard deviation of the sample means

## Draw a histogram
hist(sample_means, 
     breaks = 100,
     col="lightgreen",
     border = "white",
     las = 1,
     xlim=c(my_min, my_max), # define the limits of X axis to ensure consistency
     main=paste0("Sampling mean from a uniform distribution",
                 "\n", # newline character
                 "r=", format(r, scientific = FALSE),
                 "; n=", format(n, scientific = FALSE),
                 "; min=", my_min,
                 "; max=", my_max))

abline(v=seq(from = my_min, 
             to = my_max, 
             length.out=11), 
       col = "darkgrey") ## manually add a vertical grid 
abline(v=c(my_min, my_max), lwd=2, col="blue") # Mark the limits
abline(v=(my_max + my_min)/2, lwd=2, col="brown") # Mark the mean

arrow_height <- r/100 # a bit tricky but suitable
arrows(x0 = means_m - means_s, x1 = means_m + means_s, 
       y0 = arrow_height,  y1 = arrow_height, 
       code = 3, length = 0.1, lwd=2, 
       col="brown") ## Mark an interval of ± 1 standard deviation around the sample mean


```


### Exercice 4: impact de la taille d'échantillon


- Refaites l'expérience ci-dessus en maintenant le même nombre de répétitions ($r$), mais en faisant varier la taille d'échantillon $n$, qui prendra successivement les valeurs 1, 2, 4, 8, 16, 32, 64

Pour chaque valeur de $n$, 

- dessinez un histogramme, 
- calculez la moyenne (`mean()` la variance (`var()`) et l'écart-type (`sd()`) des moyennes d'échantillons

Quelle est la relation entre

- la taille de l'échantillon et la variance de sa moyennne ?
- la taille de l'échantillon et l'écart-type de sa moyennne ?


**Astuce: **pour automatiser l'analyse avec une série de valeurs de $n$, vous pouvez utiliser une boucle `for`. Le bloc de code ci-dessous contient déjà les paramètres et la boucle (vide), à vous d'y insérer le code pour résoudre l'exercice

```{r sampling_means_unif_sample_size, message=FALSE}

# Plot a histogram of the generated numbers
r <- 100000 # repetitions
n_values <- c(1, 2, 4, 8, 16, 32, 64)
my_min <- -5
my_max <- +5
mu <- (my_max - my_min)/2 # Theoretical mean of the uniform distribution, at mid-distance between the max and the min

## Iterate the experiments
for (n in n_values) {
  message("Repetitions: r=", r, "; Sample size: n=", n)
  
  ## Draw random numbers 
  x <- runif(n = n * r, min = -5, max = +5)
  
  ## Inject the numbers in a matrix with r rows and n columns
  x_matrix <- matrix(data = x, nrow = r, ncol = n)
  
  ## Compute sample means
  sample_means <- apply(X = x_matrix, MARGIN = 1, FUN = mean)
  
  ## Compute some statistics about the sample means
  means_m <- mean(sample_means) # compute the mean of the sample means
  means_s <- sd(sample_means) # compute the standard deviation of the sample means
  
  ## Draw a histogram
  hist(sample_means, 
       breaks = 100,
       col="lightgreen",
       border = "white",
       las = 1,
       xlim=c(my_min, my_max), # define the limits of X axis to ensure consistency
       main=paste0("Sampling mean from a uniform distribution",
                   "\n", # newline character
                   "r=", format(r, scientific = FALSE),
                   "; n=", format(n, scientific = FALSE),
                   "; min=", my_min,
                   "; max=", my_max))
  
  abline(v=seq(from = my_min, 
               to = my_max, 
               length.out=11), 
         col = "darkgrey") ## manually add a vertical grid 
  abline(v=c(my_min, my_max), lwd=2, col="blue") # Mark the limits
  abline(v=(my_max + my_min)/2, lwd=2, col="brown") # Mark the mean
  
  arrow_height <- r/100 # a bit tricky but suitable
  arrows(x0 = means_m - means_s, x1 = means_m + means_s, 
         y0 = arrow_height,  y1 = arrow_height, 
         code = 3, length = 0.1, lwd=2, 
         col="brown") ## Mark an interval of ± 1 standard deviation around the sample mean
}

```


