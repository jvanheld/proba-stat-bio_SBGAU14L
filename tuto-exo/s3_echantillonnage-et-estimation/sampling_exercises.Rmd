---
title: 'Tuto/exo: tirage de nombres d''une distribution de probabilité'
author: "Jacques van Helden (ORCID [0000-0002-8799-8584](https://orcid.org/0000-0002-8799-8584))"
date: "`r Sys.Date()`"
output:
  html_document:
    self_contained: yes
    code_folding: hide
    collapsed: true
    fig_caption: true
    highlight: zenburn
    theme: cerulean
    toc: true
    toc_depth: 3
    toc_float: true
  pdf_document:
    fig_caption: true
    highlight: zenburn
    toc: true
    toc_depth: 3
  html_notebook:
    self_contained: yes
    code_folding: show
    collapsed: false
    fig_caption: true
    highlight: zenburn
    theme: cerulean
    toc: true
    toc_depth: 3
    toc_float: true
  word_document:
    toc: true
    toc_depth: '3'
editor_options:
  chunk_output_type: console
---



```{r settings, include=FALSE, echo=FALSE, eval=TRUE}
library(knitr)

options(width = 300)
# options(encoding = 'UTF-8')
knitr::opts_chunk$set(
  fig.width = 7, fig.height = 5, 
  fig.path = 'figures/sampling_',
  fig.align = "center", 
  size = "tiny", 
  echo = TRUE, 
  eval = TRUE, 
  warning = FALSE, 
  message = FALSE, 
  results = TRUE, 
  comment = "")

options(scipen = 12) ## Max number of digits for non-scientific notation
# knitr::asis_output("\\footnotesize")

```



## Tutoriel

Dans ce tutoriel, nous illustrons quelques concepts de base de l'échantillonnage statistique, et proposons quelques exercices pour vous familiariser avec ces concepts, et avec les fonctions R pertinentes. 


```{r sampling_nomal_simple}
# Generate 100,000 numbers from a normal distribution with mean=0 and standard deviation=1
x <- rnorm(n = 100000, mean = 0, sd = 1)

# Plot a histogram of the generated numbers
hist(x, 
     main="Distribution of 100,000 random numbers from a normal distribution",
     xlab="Value")
```

### Séparation entre paramètres et exécution

Nous réécrivons ce script minimaliste en séparant les paramètres. Ceci

- améliore la lisibilité du code, 
- permet d'enrichir la documentation (commenter chaque paramètre)
- permet tester l'impact des paramètres sur le résultat

Nous utilisons la fonction `paste0()` pour écrire le titre du graphique en y incluant la valeur numérique de ces paramètres. 

Astuce : par défaut, R affiche les grands nombres en notation scientifique (ex `1e+5`). Pour éviter cela, nous remplaçons `n` par `format(n, scientific=FALSE)` dans la commande `paste0()`. 

Par convention, nous nommerons 

- `mu` la variable R qui désigne la moyenne de la distribution théorique (par référence au symbole grec $\mu$ conventionnellement utilisé)
- `sigma` la variable R qui désigne l'écart-type de la distribution théorique (par référence au symbole grec $\sigma$)




```{r sampling_normal_param}
# Parameters
n <- 100000 # Sample size
mu <- 50     # Mean of the normal distribution
sigma <- 5      # Standard deviation of the normal distribution

# Sample n numbers in a normal population of mean mu and standard deviation sigma
x <- rnorm(n = n, mean = mu, sd = sigma)

# Plot a histogram of the generated numbers
hist(x,
     main=paste0("Sampling from a normal distribution",
                 "\n", # newline character
                 "n=", format(n, scientific = FALSE),
                 ", mu=", mu,
                 ", sigma=", sigma),
     xlab="Value")

```


****************************************************************

## Exercice 1 : tirage de nombres dans une distribution aléatoire


### Distribution normale (gaussienne)

Améliorez la présentation de l'histogramme, de la façon suivante: 

- utilisez l'option `breaks` pour réduire la largeur des intervalles de classe
- choisissez une couleur qui vous plaît pour le corps et les contours de l'histogramme
- adaptez les options pour afficher horizontalement les étiquettes des axes X et Y

```{r sampling_normal}
# Parameters
n <- 100000 # Sample size
mu <- 50     # Mean of the normal distribution
sigma <- 5      # Standard deviation of the normal distribution

# Sample n numbers in a normal population of mean mu and standard deviation sigma
x <- rnorm(n = n, mean = mu, sd = sigma)

# Plot a histogram of the generated numbers


### A VOUS DE JOUER


```


****************************************************************

## Exercice 2 : tirages aléatoires dans quelques distributions théoriques


Dans les sous-sections suivantes, ajoutez des blocs de code pour effectuer un tirage dans
-les distributions suivantes

- uniforme (fonction `runif()`) dans un intervalle de $+10$ à $+20$
- $\chi^2$ chi carrée (`rchisq()`) avec 5 degrés de liberté
- Poisson (`rpois()`)) avec une espérance $\lambda=5$ 

Dans chaque cas, dessinez un histogramme pour représenter la distribution des valeurs obtenues, en indiquant le nom de la distribution et les paramètres dans le titre du graphique.

Jouez ensuite sur les paramètres pour évaluer leur impact sur la forme de la distribution. 

### Distribution uniforme


```{r sampling_uniform}

# Plot a histogram of the generated numbers
n <- 100000
my_min <- 10
my_max <- 20


## Draw random 0numbers
x <- runif(n = n, min = my_min, max = my_max)

## Plot the histogram

### A VOUS DE JOUER ###

```


### Distribution chi carrée ($\chi^2$)

Sur l'histogramme, nous marquons d'une ligne verticale la valeur des degrés de liberté. 


```{r sampling_chi2}

# Plot a histogram of the generated numbers
n <- 100000
my_df <- 5

## Draw random numbers in a chi2 distribution

### A VOUS DE JOUER ###

## Draw rthe histogram

### A VOUS DE JOUER ###


```

### Distribution de Poisson

**Astuces : ** pour la distribution Poisson, utilisez des intervalles de classe séparés par des pas de 1, allant de -0.5 jusqu'à $x_{max}+0.5$, où $x_{max}$ est le maximum des valeurs de $x$ obtenues dans votre tirage aléatoire. Pour cela, utilisez les fonctions `seq()`, `max()`. 


```{r sampling_poisson}

# Plot a histogram of the generated numbers
n <- 100000
my_lambda <- 5

## Generate te data by drawing random numbers

### A VOUS DE JOUER ###


## Draw the histogram

### A VOUS DE JOUER ###

```


****************************************************************

## Exercice 3 : distribution d'échantillonnage de la moyenne

Dans cet exercice, nous allons étudier la distribution d'échantillonnage de la moyenne, autrement dit la distribution des moyennes d'un grand nombre d'échantillons tirés aléatoirement dans une distribution théorique de notre choix (en commençant par la distribution uniforme). 

Pour cela, nous allons créer une matrice dont chaque ligne représente un tirage aléatoire  nombres, dont nous calculerons ensuite la moyenne. 

Par convention, nous nommerons nos variables

- `r` pour le nombre de répétitions de l'essai, correspondant au nombre de lignes de la matrice
- `n` pour la taille de l'échantillon, correspondant au nombre de colonnes de la matrice

**Exercice**

- Créez une matrice (avec la fonction R `matrix()`) de `r=10000` lignes et `n=5` colonnes, que vous remplirez avec des nombres aléatoires tirés dans une distribution uniforme (`runif()`) entre $10$ et $20$. 

- Calculez la moyenne marginale sur les lignes de cette matrice au  moyen de la fonction `rowMeans()`, et stockez le résultat dans un vecteur nommé `sample_means`
- Dessinez un histogramme avec les valeurs de ces moyennes marginales
- Marquez d'une barre verticale la moyenne théorique $\mu$
- Dans une autre couleur, marquez d'une barre verticale la moyenne des moyennes d'échantillon (nom de variable: `means_m`)

Interprétez les résultats : 

- Quelle est la forme générale de la distribution d'échantillonnage de la moyenne ?
- Ressemble-t-elle à la distribution théorique dont vous avez tiré les nombres ? 
- Ressemble-t-elle à une autre distribution théorique que vous connaissez ?
- La moyenne des moyennes d'échantillon correspond-elle à la moyenne théorique ?


```{r sampling_means_unif, fig.width=7, fig.height=5, out.width="80%", fig.cap="Distribution d'échantillonnage de la moyenne d'un tirage de 5 nombres dans une distribution uniforme. "}

# Plot a histogram of the generated numbers
r <- 100000     # repetitions
n <- 5          # sample size for each repetition
my_min <- 10    # min of the uniform distribution
my_max <- 20    # max of the uniform distribution

## Draw random numbers 

### A VOUS DE JOUER ###

## Inject the numbers in a matrix with r rows and n columns

### A VOUS DE JOUER ###

## Compute sample means

### A VOUS DE JOUER ###

## Compute the mean and standard deviation of the sample means

### A VOUS DE JOUER ###

## Draw a histogram

### A VOUS DE JOUER ###


```

****************************************************************

## Exercice 4: impact de la taille d'échantillon


Refaites l'expérience ci-dessus en maintenant le même nombre de répétitions ($r=`r r`$), mais en faisant varier la taille d'échantillon $n$, qui prendra successivement les valeurs $1$, $2$, $4$, $8$, $16$, $32$, $64$.

Pour chaque valeur de $n$, 

- dessinez un histogramme, 
- calculez la moyenne (`mean()` la variance (`var()`) et l'écart-type (`sd()`) des moyennes d'échantillons

Quelle est la relation entre

- la taille de l'échantillon et la variance de sa moyenne ?
- la taille de l'échantillon et l'écart-type de sa moyenne ?


**Astuce: **pour automatiser l'analyse avec une série de valeurs de $n$, vous pouvez utiliser une boucle `for`. Le bloc de code ci-dessous contient déjà les paramètres et la boucle (vide), à vous d'y insérer le code pour résoudre l'exercice

```{r sampling_means_unif_sample_size, fig.width=7, fig.height=5, out.width="80%", fig.cap="Impact de la taille d'échantillon sur la distribution d'échantillonnage de la moyenne. ", message=FALSE}

# Plot a histogram of the generated numbers
r <- 100000 # repetitions
n_values <- c(1, 2, 4, 8, 16, 32, 64)
my_min <- 10
my_max <- 20
mu <- (my_max + my_min)/2 # Theoretical mean of the uniform distribution, at mid-distance between the max and the min

## Initiate vectors to collect the sampling means parameters
means_m_values <- vector()     ## mean of the r sample means
means_sd_values <- vector()    ## standard deviation of the r sample means
means_var_values <- vector()   ## variance deviation of the r sample means

## Iterate the experiments
for (n in n_values) {
  message("Repetitions: r=", r, "; Sample size: n=", n)
  
  ## Draw random numbers 
  x <- runif(n = n * r, min = my_min, max = my_max)
  
  ## Inject the numbers in a matrix with r rows and n columns
  x_matrix <- matrix(data = x, nrow = r, ncol = n)
  
  ## Compute sample means
  sample_means <- apply(X = x_matrix, MARGIN = 1, FUN = mean)
  
  ## Compute some statistics about the sample means
  means_m <- mean(sample_means) # compute the mean of the sample means

  ## We compute it manually because R var() divides by n-1, which estimates the population variance but is not appropriate for the sample variance we need here
  means_var <- sum((sample_means - means_m)^2)/r # compute the variance of the sample means. 
  # means_var <- (r-1)/r * var(sample_means) # compute the variance of the sample means. We correct the corrective factor r-1, which serves to infer the population mean
  means_sd <- sqrt(means_var) # compute the standard deviation of the sample means
  
  ## Append the current parameters to the vectors  
  means_m_values <- c(means_m_values, means_m)
  means_sd_values <- c(means_sd_values, means_sd)
  means_var_values <- c(means_var_values, means_var)
  
  ## Draw a histogram
  hist(sample_means, 
       breaks = 100,
       col="lightgreen",
       border = "white",
       las = 1,
       xlim=c(my_min, my_max), # define the limits of X axis to ensure consistency
       main=paste0("Sampling mean from a uniform distribution",
                   "\n", # newline character
                   "r=", format(r, scientific = FALSE),
                   "; n=", format(n, scientific = FALSE),
                   "; min=", my_min,
                   "; max=", my_max))
  
  abline(v=seq(from = my_min, 
               to = my_max, 
               length.out=11), 
         col = "darkgrey") ## manually add a vertical grid 
  abline(v=c(my_min, my_max), lwd=2, col="darkblue") # Mark the limits
  abline(v=mu, lwd=1, col="blue") # Mark the mean
  abline(v=means_m, lwd=2, col="orange", lty = "dashed") # Mark the mean
  
  arrow_height <- r/100 # a bit tricky but suitable
  arrows(x0 = means_m - means_sd, x1 = means_m + means_sd, 
         y0 = arrow_height,  y1 = arrow_height, 
         code = 3, length = 0.1, lwd=2, 
         col="brown") ## Mark an interval of ± 1 standard deviation around the sample mean
  
  
  legend(
    "topright",
    legend = c(
      paste0("mu = ", mu), 
      paste0("means_m = ", round(means_m, digits = 5)), 
      paste0("means_sd = ", round(means_sd, digits = 4)),
      paste0("means_var = ", round(means_var, digits = 4))
      ),
    col = c("blue", "orange", "brown", NULL),
    lty = c("solid", "dashed", "solid", NULL),
    lwd=c(1,2,2, 0),
    cex=0.8
  )
}

## Print a table with the results
kable(
  data.frame(n = n_values,
             m = means_m_values,
             var = means_var_values,
             sd = means_sd_values),
  digits = c(0, 5, 3, 3), 
  caption = "Impact of sample size (n) on the mean, variance and standard deviation of the sampling means. ")

```





```{r impact_sample_size_var_of_means}
## Plot the variance of sampling means as a function of sample size
plot(n_values, means_var_values, 
     type = "b",
     pch = 19,
     lty = "dashed",
     col = "brown",
     main = "Impact of sample size on the variance of sampling means",
     ylim = c(0, ceiling(max(means_var_values))),
     ylab = paste0("Variance of the sampling mean (", r, " repetitions)"),
     xlab = "Sample size (n)",
     las = 1,
     panel.first = c(grid(),
                     abline(h=0, col="black"))
     )


```


```{r impact_sample_size_var_of_means_logX}
## Plot the variance of sampling means as a function of sample size
plot(n_values, means_var_values, 
     type = "b",
     pch = 19,
     lty = "dashed",
     col = "brown",
     log = "xy",
     main = "Impact of sample size on the variance of sampling means\n(logarithmic X and Y scales)",
     ylab = paste0("Variance of the sampling mean (", r, " repetitions)"),
     xlab = "Sample size (n)",
     las = 1,
     panel.first = c(grid(, equilogs = FALSE))
     )


```




```{r impact_sample_size_sd_of_means}
## Plot the standard deviation of sampling means as a function of sample size
plot(n_values, means_sd_values, 
     type = "b",
     pch = 19,
     lty = "dashed",
     col = "brown",
     main = "Impact of sample size on the standard deviation of sampling means",
     ylim = c(0, ceiling(max(means_sd_values))),
     ylab = paste0("Standard deviation of the sampling mean (", r, " repetitions)"),
     xlab = "Sample size (n)",
     las = 1,
     panel.first = c(grid(),
                     abline(h=0, col="black"))
     )


```


```{r impact_sample_size_mean_of_means}
## Plot the mean of sampling means as a function of sample size
plot(n_values, means_m_values, 
     type = "p",
     pch = 19,
     lty = "solid",
     col = "orange",
     main = "Impact of sample size on the distribution of sampling means",
     ylim = c(my_min, my_max), 
     ylab = paste0("Mean of the sampling mean (", r, " repetitions)"),
     xlab = "Sample size (n)", 
     las = 1,
     panel.first = c(grid(),
                     abline(h = mu, col = "blue", lwd = 1))
     )


arrows(x0 = n_values, x1 = n_values, 
       y0 = means_m_values - means_sd_values,  y1 = means_m_values + means_sd_values, 
       code = 3, length = 0.07, lwd=2, 
       col="brown") ## Mark an interval of ± 1 standard deviation around the mean
legend("topright",
       legend = c("mu", "mean of the means", "standard deviation of the means"),
       lwd = c(1, 0, 2),
       pch=c(NA, 19, NA),
       col = c("blue", "orange", "brown")
)

```


### Erreur standard (standard error)


| Parameter | Formula |
|----------------|-------------------------|
| Sample mean | $\bar{x}$ |
| Variance of the sample mean | $\sigma^2_{\bar{x}} = \frac{\sigma^2}{n}$ |
| Standard error | $\sigma_{\bar{x}} = \frac{\sigma}{\sqrt(n)}$ |

****************************************************************
****************************************************************
