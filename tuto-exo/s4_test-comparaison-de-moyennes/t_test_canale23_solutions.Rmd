---
title: "Tuto et TP: tests de comparaison de moyenne"
subtitle: "Proba/stat pour la biologie (SBGAU14L)"
author: "Jacques van Helden (ORCID [0000-0002-8799-8584](https://orcid.org/0000-0002-8799-8584))"
date: '`r Sys.Date()`'
output:
  html_document:
    code_folding: hide
    fig_caption: yes
    highlight: zenburn
    theme: cerulean
    toc: yes
    toc_depth: 3
    toc_float: yes
  word_document:
    toc: yes
    toc_depth: 3
  ioslides_presentation:
    colortheme: dolphin
    fig_caption: yes
    fig_height: 6
    fig_width: 7
    fonttheme: structurebold
    highlight: tango
    incremental: no
    keep_md: no
    smaller: yes
    theme: cerulean
    toc: yes
    widescreen: yes
  beamer_presentation:
    colortheme: dolphin
    fig_caption: yes
    fig_height: 6
    fig_width: 7
    fonttheme: structurebold
    highlight: tango
    incremental: no
    keep_tex: no
    slide_level: 2
    theme: Montpellier
    toc: yes
  slidy_presentation:
    fig_caption: yes
    fig_height: 6
    fig_width: 7
    highlight: tango
    incremental: no
    keep_md: no
    smaller: yes
    theme: cerulean
    toc: yes
    toc_float: yes
    widescreen: yes
  pdf_document:
    fig_caption: yes
    highlight: zenburn
    toc: yes
    toc_depth: 3
---

```{r settings, include=FALSE, echo=FALSE, eval=TRUE}
library(knitr)

options(width = 300)
# options(encoding = 'UTF-8')
knitr::opts_chunk$set(
  fig.width = 7, fig.height = 5, 
  fig.path = 'figures/canale23_',
  fig.align = "center", 
  size = "tiny", 
  echo = TRUE, 
  eval = TRUE, 
  warning = FALSE, 
  message = FALSE, 
  results = TRUE, 
  comment = "")

options(scipen = 12) ## Max number of digits for non-scientific notation
# knitr::asis_output("\\footnotesize")

```




## But de ce TP

Le but de ce TP est de mettre en oeuvre un test $t$ de Student pour comparer les moyennes des niveaux d'abondance du protéome, entre deux types de tissus: 

- foie (*liver*)
- hépatocarinome cellulaire (*HCC*)

**Approche pédagogique : ** avant de présenter la théorie ou de procéder au test statistique à proprement parler, nous allons effectuer quelques analyses empiriques sur l'ensemble de nos données de protéome, pour acquérir une intuition de leur structuration : 

- moyennes d'échantillons de chaque protéine pour les deux tissus respectifs
- variances et écart-types d'échantillons pour chaque protéines
- relation entre moyennes et variances

## Téléchargement et chargement des données

Lors du TP précédent, nous avons téléchargé les données de Canale (2023) dans notre dossier de travail. 
Nous reprenons le même code pour nous assurer qu'elles se trouvent bien dans le dossier data, et que les tables de données ont les  dimensions attendues; 


### Downloading datasets from the github repository


```{r data_download}

## This  chunk of code below automatically performs the following operations
## 1. Define the working directory, check if it exists and if not create it
## 2. Define the data directory, check if it exists and if not create it
## 3. Download the proteomics data (quantification table) 
##    and metadata (protein names, sample groups) in the data directory. 
##    If the files are already present, the download is skipped. 

## Working dir 
working_dir <- "~/proba_stat_bio_TP/canale_2023"
dir.create(working_dir, recursive = TRUE, showWarnings = FALSE)
setwd(working_dir)
message("Working directory: ", working_dir)

#### Check data directory and create it if necessary ####
data_dir <- file.path(working_dir, "data")
dir.create(data_dir, recursive = TRUE, showWarnings = FALSE)
message("Data directory: ", data_dir)


## Define file names
files <- c("canale_2023_protein_log2-LFQ.tsv", 
           "canale_2023_protein-names.tsv", 
           "sample_groups.tsv")

## Download the data from github to the local data dir
repo_base <- "https://raw.githubusercontent.com/jvanheld/proba-stat-bio_SBGAU14L/refs/heads/main/data/canale_2023/"


for (f in files) {
  ## Define the destination path (data dir + file name)
  dest_file <- file.path(data_dir, f)
  
  ## Check if the file is already there, and if so skip, else download it
  if (file.exists(dest_file)) {
    message("File ", f, " already here, skipping the download")
  } else {
    source_url <- file.path(repo_base, f)
    message("Downloading file ", f, " from github")
    download.file(source_url, dest_file, quiet = FALSE)
  }
}

```


| | |
|-----------------------|----------------------------------------------------|
| Working directory: | `r working_dir` |
| Data directory: | `r data_dir` |
| Files present in the data directory | `r list.files(data_dir)` |

### Data loading


We will load 3 data files, that will be used at different stages of our analysis. 
These files are provided as text files, with columns separated by tabulations (the so-called "tab-separated values" format, with extension `.tsv`).

| File | Content |
|------------------------------|-------------------------------------------|
| `canale_2023_protein_log2-LFQ.tsv` | The proteomics quantification table, with one row per protein, and one column per sample. Note that the first column provides protein IDs, and the first row sample IDs |
| `canale_2023_protein-names.tsv` | One row per protein, and columns with the protein IDs, protein names and gene names. Note that a protein can have one or more IDs (allocated by different databases), and zero, one or more protein or gene names (some proteins/genes of unknown function have no name, ans some proteins/genes can have several synonyms). |
| `sample_groups.tsv` | A 3-columns tab-separated files containing one row per sample ID (first column, used as row names), and its decomposition in two fields indicating the group to which each sample belongs, and the patient ID (number). In this study case, there are only two groups : **HCC** for Human cancer cells, and **Liver** for liver cells.

```{r data_loading}
message("Loading the datasets")

#### Load the data file ####
log2_LFQ = read.delim(
  file = file.path(data_dir, "canale_2023_protein_log2-LFQ.tsv"), 
  sep="\t", 
  header=TRUE, 
  row.names=1)

## Load a separate table indicating which sample belongs to which group (cancer or liver cells)
sample_groups = read.delim(
  file.path(data_dir, "sample_groups.tsv"), 
  sep="\t", 
  header=TRUE, 
  row.names=1)

## Load the protein names from a separate table
protein_names = read.delim(file = file.path(data_dir, "canale_2023_protein-names.tsv"), sep = "\t", row.names = 1, header = TRUE)
# View(protein_names)
```

The data and metadata files have been loaded in the following R variables. 

| Variable | Rows | Columns | Content | 
|-------------|-----|------|------------------------------------|
| `log2_LFQ` | `r nrow(log2_LFQ)` | `r ncol(log2_LFQ)` | Protein quantification table, in log2(LFQ), where LFQ stands for label-free quantification. One row per protein, one column per sample |
| `protein_names` | `r nrow(protein_names)` | `r ncol(protein_names)` | Protein identifiers, protein names and gene names. One row per protein |
| `sample_groups` | `r nrow(sample_groups)` | `r ncol(sample_groups)` | One row per sample, two columns inidicating its group and its patient identifier (number) |

In the table above, check carefully the consistency between the dimensions of the 3 tables : 

- `protein_names` should have the same number of rows as `log2_LFQ` (one row per protein)
- the number of rows of `sample_groups` (one row per sample) should equal the number of columns of `log2_LFQ` (one column per sample)


****************************************************************
## Moyennes d'échantillons par type de tissu

Lors du TP précédent, nous avons mesuré les statistiques marginales (moyenne, écart-type) pour chaque protéine, tous échantillons confondus. 
Nous allons maintenant calculer les mêmes statistiques en séparant les échantillons par type tissulaire : 

- *liver*: foie
- *HCC*: hépatocarcinome cellulaire

Pour cela nous allons utiliser la table de métadonnées `sample_groups`.

**Exercice : ** 
- Utilisez pour cela la fonction `subset()` pour sélectionner les noms d'échantillons correspondant aux deux types cellulaires. 
- A partir de la data.frame `log2_LFQ` qui contient les données protéomiques de tous les échantillons, créez deux data.frames nommées respectivement `log2_LFQ_liver` et  `logLFQHCC` avec le sous-ensemble de colonnes des tissus correspondants. 
- Calculez les moyennes marginales respectives des échantillons de foie et de cellules hépatocarcinome cellulaire, et stockez-les dans des vecteurs nommés respectivement `mean_per_protein_liver` et  `mean_per_protein_HCC`. 
- Dessinez un nuage de points (scatter plot) représentant la moyenne marginale des échantillons HCC (ordonnée) en fonction de la moyenne marginale des échantillons de foie (abscisse). Ajoutez une ligne (`abline()`) qui marque la médiane de ce graphique. 


**Astuces : **

- Pour vous faciliter la tâche, nous fournissons les étapes de sélection pour l'un des types tissulaires, nous vous laissons ajouter les commandes pour traiter le deuxième. 
- Utilisez la fonction R `densCols()` pour indiquer les régions où se superposent un grand nombre de points


```{r plot_mean_per_group, fig.width=8, fig.height=8, out.width="90%", fig.cap="Sample means per tissue type. HCC: Hepatocarcinome cells. "}
## Select the sample labels for the two tissue types
liver_samples <- rownames(subset(sample_groups, group=="Liver"))
HCC_samples <- rownames(subset(sample_groups, group=="HCC"))

## Compute the sample size per group
n_liver <- length(liver_samples)
n_HCC <- length(HCC_samples)

## Extract two subsets of the proteome abundance table, corresponding to the two tissue table
log2_LFQ_liver <- log2_LFQ[, liver_samples]
log2_LFQ_HCC <- log2_LFQ[, HCC_samples]
# dim(log2_LFQ_liver)
# dim(log2_LFQ_HCC)

## Compute marginal means per protein for each tissue type
mean_per_protein_liver <- apply(log2_LFQ_liver, 1, mean, na.rm = TRUE)
mean_per_protein_HCC <- apply(log2_LFQ_HCC, 1, mean, na.rm = TRUE)

mean_min = floor(min(mean_per_protein_liver, mean_per_protein_HCC, na.rm = TRUE))
mean_max = ceiling(max(mean_per_protein_liver, mean_per_protein_HCC, na.rm = TRUE))

## Scatter plot of the means per group
plot(mean_per_protein_liver, 
     mean_per_protein_HCC, 
     col=densCols(
       x = mean_per_protein_liver, 
       y = mean_per_protein_HCC),
     main = "Mean abundance per protein: Liver versus HCC",
     xlab = "mean(log2_LFQ), liver", 
     ylab = "mean(log2_LFQ), HCC", 
     xlib=c(mean_min, mean_min),
     ylib=c(mean_min, mean_min),
     las=1)
grid() ## Add a grid
abline(a = 0, b = 1, col = "brown", lwd=2)

```

****************************************************************
## Variances par tissu


**Exercice : ** suivez la même procédure pour produire un graphique représentant les variances marginales par protéine, pour les tissus HCC et Liver. 

```{r plot_var_per_group, fig.width=8, fig.height=8, out.width="90%", fig.cap="Standard deviation per tissue type. HCC: Hepatocarcinome cells. "}

## Compute marginal variances per protein for each tissue type
var_per_protein_liver <- apply(log2_LFQ_liver, 1, var, na.rm=TRUE) * sqrt((n_liver -1 ) /n_liver)
var_per_protein_HCC <- apply(log2_LFQ_HCC, 1, var, na.rm=TRUE) * sqrt((n_HCC -1 ) /n_HCC)

var_max <- ceiling(max(var_per_protein_liver, var_per_protein_HCC, na.rm = TRUE))

## Scatter plot of the variances per group
plot(var_per_protein_liver, 
     var_per_protein_HCC, 
     main = "Standard deviation of the abundance per protein: Liver versus HCC",
     xlab = "var(log2_LFQ), liver", 
     ylab = "var(log2_LFQ), HCC", 
     xlim = c(0, var_max),
     ylim=c(0, var_max),
     col=densCols(
       x = var_per_protein_liver, 
       y = var_per_protein_HCC),
     las=1)
grid() ## Add a grid
abline(a = 0, b = 1, col = "brown", lwd=2)

```

****************************************************************
## Ecarts-types par tissu


**Exercice : ** suivez la même procédure pour produire un graphique représentant les écarts-types marginaux par protéine, pour les tissus HCC et Liver. 

```{r plot_sd_per_group, fig.width=8, fig.height=8, out.width="90%", fig.cap="Standard deviation per tissue type. HCC: Hepatocarcinome cells. "}

## Compute marginal standard deviations per protein for each tissue type
sd_per_protein_liver <- apply(log2_LFQ_liver, 1, sd, na.rm=TRUE) * sqrt((n_liver -1 ) /n_liver)
sd_per_protein_HCC <- apply(log2_LFQ_HCC, 1, sd, na.rm=TRUE) * sqrt((n_HCC -1 ) /n_HCC)

sd_max <- ceiling(max(sd_per_protein_liver, sd_per_protein_HCC, na.rm = TRUE))

## Scatter plot of the standard deviations per group
plot(sd_per_protein_liver, 
     sd_per_protein_HCC, 
     main = "Standard deviation of the abundance per protein: Liver versus HCC",
     xlab = "sd(log2_LFQ), liver", 
     ylab = "sd(log2_LFQ), HCC", 
     xlim = c(0, sd_max),
     ylim=c(0, sd_max),
     col=densCols(
       x = sd_per_protein_liver, 
       y = sd_per_protein_HCC),
     las=1)
grid() ## Add a grid
abline(a = 0, b = 1, col = "brown", lwd=2)

```


****************************************************************
## Moyenne versus écart-type

**Exercice : ** pour chaque type de tissu, dessinez un graphique de type nuage de points, avec en abscisse la moyenne et en ordonnée l'écart-type 

```{r mean_vs_sd_liver, fig.width=8, fig.height=8, out.width="90%", fig.cap="Mean versus standard deviation in liver samples. "}

## Scatter plot of the mean versus standard deviation
plot(mean_per_protein_liver, 
     sd_per_protein_liver, 
     main = "Standard deviation versus mean of the abundance per protein in liver tissue",
     xlab = "mean(log2_LFQ), liver", 
     ylab = "sd(log2_LFQ), mean", 
     xlim = c(mean_min, mean_max),
     ylim=c(0, sd_max),
     col=densCols(
       x = sd_per_protein_liver, 
       y = sd_per_protein_HCC),
     las=1)
grid() ## Add a grid
abline(a = 0, b = 1, col = "brown", lwd=2)

```


```{r mean_vs_sd_HCC, fig.width=8, fig.height=8, out.width="90%", fig.cap="Mean versus standard deviation in HCC samples. "}

## Scatter plot of the mean versus standard deviation
plot(mean_per_protein_HCC, 
     sd_per_protein_HCC, 
     main = "Standard deviation versus mean of the abundance per protein in HCC tissue",
     xlab = "mean(log2_LFQ), HCC", 
     ylab = "sd(log2_LFQ), mean", 
     xlim = c(mean_min, mean_max),
     ylim=c(0, sd_max),
     col=densCols(
       x = sd_per_protein_HCC, 
       y = sd_per_protein_HCC),
     las=1)
grid() ## Add a grid
abline(a = 0, b = 1, col = "brown", lwd=2)

```


****************************************************************
## Réalisation d'un test de comparaison de moyennes

Notre exploration visuelle des données nous donne de bonnes raisons de penser que .... hétéroscédasticité --> test de Welch


```{r welch_one_protein}
goi <- "UGP2" ## Gene of interest
poi <- "Q16851" ## Protein of interest

## First writing for the t.test() : send 2 vectors of values (one per sample)

## Select the observations for the protein of interest
HCC_samples <- rownames(subset(sample_groups, group == "HCC"))
liver_samples <- rownames(subset(sample_groups, group == "Liver"))

HCC_values <-log2_LFQ[poi, HCC_samples]
liver_values <-log2_LFQ[poi, liver_samples]

welch_result <- t.test(
  x = HCC_values, y = liver_values, 
  alternative = "two.sided", 
  var.equal = FALSE)
print(welch_result)


## Alternative call to the t.test() funciton: send a vector with all values, and another one with the group of each element
values <- unlist(log2_LFQ[poi, ])
group_labels <- unlist(sample_groups[colnames(log2_LFQ), "group"])

welch_result <- t.test(
  values ~ group_labels,
  alternative = "two.sided", 
  var.equal = FALSE)
print(welch_result)


```


****************************************************************
## Analyse différentielle du protéome

```{r welch_proteome}


## Data filtering : filter out proteins having too few numeric values in one of the groups
min_values_per_group <- 3

## Count number of NA values per group for each protein
n_HCC_per_prot <- apply(!is.na(log2_LFQ[, HCC_samples]), 1, sum)
n_liver_per_prot <- apply(!is.na(log2_LFQ[, liver_samples]), 1, sum)

# kable(table(n_HCC_per_prot > min_values_per_group, n_liver_per_prot > min_values_per_group))

selected_proteins <- (n_HCC_per_prot > min_values_per_group) & (n_liver_per_prot > min_values_per_group)
# table(selected_proteins)

## Define a function that runs a t test and returns the quantitative results as a vector.
## This enables to use it with apply() in order to run the t test on each row of a omics data table.
my_t <- function (values, groups, ...) {
 t_result <- t.test(values ~ groups, ... )
 t_result_vector <- c(
   t = unname(t_result$statistic),
   df = unname(t_result$parameter),
   p = t_result$p.value,
   conf.int = t_result$conf.int,
   xbar_1 = unname(t_result$estimate[1]),
   xbar_2 = unname(t_result$estimate[2]),
   t_result$estimate[1],
   M = unname(t_result$estimate[1] - t_result$estimate[2]),
   A = unname(t_result$estimate[1] + t_result$estimate[2])/2)
 return(t_result_vector)
}


## Compute a table with all the t-test results. 
## This returns a data frame with one row per protein and one column per statistics. 
proteome_t <- as.data.frame(t(apply(
  log2_LFQ[selected_proteins,], 
  1, my_t, 
  group_labels,   
  alternative = "two.sided", 
  var.equal = FALSE)))

## Re-compute the t statistics for checking

### TO DO JvH ###


## Add a column with the E-value
proteome_t$E <- proteome_t$p * nrow(proteome_t)  ## E-value
proteome_t$sig <- -log10(proteome_t$E)    ## Significance
  
## Add a column with the protein name
proteome_t$gene_name <- protein_names[rownames(proteome_t), "Gene.name"]
proteome_t$protein_name <- protein_names[rownames(proteome_t), "Protein.name"]

# View(proteome_t)
# plot(proteome_t$M, proteome_t$t)

## Export the differential analysis results
result_dir <- file.path(working_dir, "results")
dir.create(result_dir, showWarnings = FALSE, recursive = TRUE)

## Tab-separated values
write.table(proteome_t, 
            file = file.path(result_dir, "proteome_differential_analysis.tsv"),
            sep = "\t", row.names = TRUE, col.names = NA)

## Excel file
if (!require(xlsx)) {
  install.packages("xlsx")
}
library(xlsx)
write.xlsx(x = proteome_t, file = file.path(result_dir, "proteome_differential_analysis.xlsx"))

```


### Taille d'effet (*effect size*)

La taille d'effet est la différence entre les moyennes des échantillons. Dans notre cas, il s'agit d'une différence entre deux logarithmes, ce qui revient à calculer un ***log2 fold change*** entre les LFQ des deux tissus. 

$$
d = \log_2(\text{LFQ}_{\text{liver}}) - \log_2(\text{LFQ}_{\text{HCC}})
= \log_2\!\left(\frac{\text{LFQ}_{\text{liver}}}{\text{LFQ}_{\text{HCC}}}\right)
$$

### MA plot

Le "MA" plot revient à dessiner la taille d'effet (***effect size***) en ordonnée en fonction de l'intensité moyenne du signal (abscisse). 

$$M = d = log_2(\bar{x}_1) - log_2(\bar{x}_2)$$
$$A = \frac{1}{2} \left[log_2(\bar{x}_1) + log_2(\bar{x}_2) \right] $$



```{r MA_plot, fig.width=8, fig.height=7, out.width="100%", fig.cap="MA plot of the proteome differential analysis. "}
#### MA plot ####
plot(proteome_t$A, 
     proteome_t$M, 
     main = "MA-plot of the proteome differential analysis\nCanale (2023)",
     xlab = "Average signal (A)",
     ylab = "Difference (M)",
     col = densCols(proteome_t$A, proteome_t$M),
     las =  1,
     panel.first = grid())
abline(h=0, col="darkgrey")

## Thresholds on effect size and significance
threshold_M <- 2    ## Threshold on effect size (=log2(FC))
abline(h = c(-threshold_M, +threshold_M), col="darkgreen")

## Recolor significant proteins
selected_up <- rownames(subset(proteome_t, M > threshold_M))
selected_down <- rownames(subset(proteome_t, M < -threshold_M))
lines(proteome_t[selected_up, "A"],
      proteome_t[selected_up, "M"],
      type = "p", pch=20, col = "#00AA00", cex=0.5)
lines(proteome_t[selected_down, "A"],
      proteome_t[selected_down, "M"],
      type = "p", pch=20, col = "red", cex=0.5)


## Add a label to the top most significant proteins
to_label_n <- 12
to_label <- proteome_t[order(proteome_t$p), ][1:to_label_n, ]
text(x = to_label$d,
     y = -log10(to_label$p) - 0.4, 
     labels = to_label$gene_name, cex = 0.7)

```


On this graph, we arbitrarily marked a threshold of 2 on the absolute log2 fold change, which amounts to a fold-change of 4 in any direction between liver and HCC samples. 


### Volcano plot

Le volcano plot est utilisé pour visualiser les résultats d'un grand ensemebl de tests statistiques, en représentant la significativité de chaque test ($-log_{10}(P)$) en fonction de la taille d'effet ($d$). 

```{r volcano_plot, fig.width=8, fig.height=7, out.width="100%", fig.cap="Volcano plot of the proteome differential analysis. "}
#### Volcano plot ####
y <- -log10(proteome_t$p)
plot(proteome_t$M, 
     y, 
     main = "Volcano plot of the proteome differential analysis\nCanale (2023)",
     xlab = "Effect size (liver - HCC)",
     ylab = "-log10(P-value)",
     col = densCols(proteome_t$M, y),
     las =  1,
     panel.first = grid())
abline(v=0, col="darkgrey")
abline(h=0, col="darkgrey")

## Thresholds on effect size and significance
threshold_M <- 2    ## Threshold on effect size (=log2(FC))
threshold_E <- 0.05 ## Conservative Bonferoni threshold

N <- nrow(proteome_t)
abline(h = -log10(threshold_E), col="violet")
abline(h = -log10(threshold_E/N), col="darkgreen")
abline(h = log10(N), col="brown")
abline(v = c(-threshold_M, +threshold_M), col="darkgreen")

## Recolor significant proteins
selected_up <- rownames(subset(proteome_t, (E < threshold_E) & (M > threshold_M))) 
selected_down <- rownames(subset(proteome_t, (E < threshold_E) & (M < -threshold_M))) ## Conservative Bonferoni threshold
lines(proteome_t[selected_up, "M"], 
      -log10(proteome_t[selected_up, "p"]), 
      type = "p", pch=20, col = "#00AA00", cex=0.5)
lines(proteome_t[selected_down, "M"], 
      -log10(proteome_t[selected_down, "p"]), 
      type = "p", pch=20, col = "red", cex=0.5)


## Add a label to the top most significant proteins
to_label_n <- 12
to_label <- proteome_t[order(proteome_t$p), ][1:to_label_n, ]
text(x = to_label$M,
     y = -log10(to_label$p) - 0.4, 
     labels = to_label$gene_name, cex = 0.7)

```



****************************************************************
## Formules mathématiques

- Les syboles grecs ($\mu$, $\sigma$) correspondent aux statistiques de population, les symboles romains ($\bar{x}$, $s$) aux statistiques d'échantillon.
- L'accent circonflexe ($\hat{ }$) indique les estimateurs de paramètres de population calculés à partir de paramètres d'échantillons. 

| Symboles et formules       | Description   |
|--------------|----------------------------------------------------|
| $\mu_{1},  \mu_{2}$ | Moyennes respectives des populations 1 et 2. |
| $\sigma_{1}, \sigma_{2}$ | Ecarts-types respectifs des populations 1 and 2. |
| $N_1$, $N_2$ | Tailles (nombre d'individus) des populations 1 et 2. |
| $n_1$, $n_2$ | Effectifs (nombre d'individus) des échantillons prélevés sur les populations 1 et 2. |
| $\bar{x}_{1}, \bar{x}_{2}$ | Moyennes d'échantillons. |
| $\delta = \mu_{2} - \mu{1}$ | Différence entre les moyennes des populations. |
| $d = \hat{\delta} = \hat{\mu}_2 - \hat{\mu}_1  = \bar{x}_2 - \bar{x}_1$ | $d$ = **Taille d'effet**: dans un test de comparaison de moyennes, il s'agit de la différence entre les moyennes d'échantillons, utilisée comme estimateur de $\delta$. |
| $s^2_{1}, s^2_{2}$ | Variances mesurées sur les échantillons. |
| $\hat{\sigma}_p = \sqrt{\frac{n_1 s_1^2 + n_2 s_2^2}{n_1+n_2-2}}$ | Ecart-type groupé (*pooled standard deviation*), utilisé comme estimateur de l'écart-type commun des deux populations, en supposant leurs variances égales (hypothèse de travail d'homoscédasticité). |
| $\hat{\sigma}_\delta = \hat{\sigma}_p \sqrt{\left(\frac{1}{n_1}+ \frac{1}{n_2}\right)}$  | Erreur standard sur la différence entre moyennes, en supposant que les populations ont la même variance (test de Student). |
| $t_{S} = \frac{\hat{\delta}}{\hat{\sigma}_\delta} =  \frac{\bar{x}_{2} - \bar{x}_{1}}{\sqrt{\frac{n_1 s_{1}^2 + n_2 s_{2}^2}{n_1+n_2-2} \left(\frac{1}{n_1}+ \frac{1}{n_2}\right)}}$ | statistique $t$ de Student |
| $t_{W}=\frac{\bar{x}_{1} - \bar{x}_{2}}{\sqrt{\frac {s^2_{1}}{n_1} + \frac{s^2_{2}}{n_2}}}$ | statistique $t$ de Welch |
| | |

